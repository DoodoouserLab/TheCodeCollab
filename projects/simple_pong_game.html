<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Complicated Territorial.io – Scandinavia Edition (HTML)</title>
  <style>
    /* Basic reset and centering */
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background-color: #0000FF; /* blue background (water) */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1200" height="800"></canvas>
  <script>
    // Global Constants
    const SCREEN_WIDTH = 1200;
    const SCREEN_HEIGHT = 800;
    const FPS = 30;

    // Team colors by owner (Player, Bot1, Bot2)
    const TEAM_COLORS = {
      "Player": "#00C800", // green
      "Bot1": "#C80000",   // red
      "Bot2": "#0000C8"    // blue-ish
    };

    // Standard colors
    const BLUE = "#0000FF";  // water and background
    const WHITE = "#FFFFFF";
    const BLACK = "#000000";

    // ------------------------------
    // Utility Functions
    // ------------------------------

    // Compute the center of a polygon (average of all vertices)
    function computeCenter(polygon) {
      let sumX = 0, sumY = 0;
      for (let pt of polygon) {
        sumX += pt[0];
        sumY += pt[1];
      }
      return [sumX / polygon.length, sumY / polygon.length];
    }

    // Ray-cast algorithm to check if a point [x,y] is within a polygon
    function pointInPolygon(point, polygon) {
      let x = point[0], y = point[1];
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        let xi = polygon[i][0], yi = polygon[i][1];
        let xj = polygon[j][0], yj = polygon[j][1];
        let intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    // Helper to determine if two line segments (p1→p2 and p3→p4) intersect.
    function linesIntersect(p1, p2, p3, p4) {
      function ccw(a, b, c) {
        return (c[1] - a[1]) * (b[0] - a[0]) > (b[1] - a[1]) * (c[0] - a[0]);
      }
      return (ccw(p1, p3, p4) !== ccw(p2, p3, p4)) && (ccw(p1, p2, p3) !== ccw(p1, p2, p4));
    }

    // Check if a line between two points (p1, p2) crosses any edge of a polygon
    function lineIntersectsPolygon(p1, p2, polygon) {
      for (let i = 0; i < polygon.length; i++) {
        const p3 = polygon[i];
        const p4 = polygon[(i + 1) % polygon.length];
        if (linesIntersect(p1, p2, p3, p4)) {
          return true;
        }
      }
      return false;
    }

    // Determine whether the direct route between two territories goes over water.
    function requiresBoat(fromTerritory, toTerritory, waterTerritories) {
      const start = computeCenter(fromTerritory.polygon);
      const end = computeCenter(toTerritory.polygon);
      for (let water of waterTerritories) {
        if (lineIntersectsPolygon(start, end, water.polygon)) {
          return true;
        }
      }
      return false;
    }

    // ------------------------------
    // Class Definitions
    // ------------------------------

    // Territory: a polygon on our map.
    class Territory {
      constructor(name, polygon, owner, isWater = false) {
        this.name = name;
        this.polygon = polygon;  // array of [x, y] points
        this.owner = owner;      // "Player", "Bot1", etc.
        this.isWater = isWater;
        if (!isWater) {
          this.population = Math.floor(Math.random() * 71) + 50; // random between 50 and 120
          this.growthRate = Math.random() * 0.4 + 0.1;           // random between 0.1 and 0.5
        } else {
          this.population = 0;
          this.growthRate = 0;
        }
        this.neighbors = []; // will be assigned manually
      }
      updatePopulation() {
        if (!this.isWater) {
          this.population += this.growthRate;
        }
      }
    }

    // Unit: an army (or boat unit) moving from one territory to another.
    class Unit {
      constructor(fromTerritory, toTerritory, number, isBoat = false, owner = null) {
        this.fromTerritory = fromTerritory;
        this.toTerritory = toTerritory;
        this.number = number;
        this.isBoat = isBoat;
        this.owner = owner;
        this.progress = 0; // 0 (start) to 1 (arrival)
      }
      update(dt) {
        const travelTime = this.isBoat ? 3.0 : 2.0; // boat units move slower
        this.progress += dt / travelTime;
      }
    }

    // Main Game class manages updating, rendering, and actions.
    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.lastTime = performance.now();

        this.territories = [];
        this.waterTerritories = [];
        this.units = [];

        // ----- Setup Territories (Map of Scandinavia) -----
        // Arbitrary coordinates for demonstration purposes.
        const norway = new Territory("Norway", [[100, 100], [300, 100], [280, 300], [120, 300]], "Bot1");
        const sweden = new Territory("Sweden", [[300, 100], [550, 120], [580, 300], [280, 300]], "Player");
        const finland = new Territory("Finland", [[580, 300], [600, 300], [630, 400], [580, 400]], "Bot1");
        const denmark = new Territory("Denmark", [[280, 300], [580, 300], [500, 500], [200, 500]], "Bot2");

        this.territories.push(norway, sweden, finland, denmark);

        // Define neighboring relationships manually.
        norway.neighbors = [sweden, denmark];
        sweden.neighbors = [norway, finland, denmark];
        finland.neighbors = [sweden, denmark];
        denmark.neighbors = [norway, sweden, finland];

        // Water territories: drawn in blue and cannot be claimed.
        const skagerrak = new Territory("Skagerrak", [[280, 300], [580, 300], [580, 320], [280, 320]], null, true);
        const baltic = new Territory("Baltic Sea", [[580, 300], [630, 310], [630, 400], [580, 400]], null, true);
        this.waterTerritories.push(skagerrak, baltic);

        this.bots = ["Bot1", "Bot2"];
        this.player = "Player";

        // Add mouse click event listener for player actions.
        this.canvas.addEventListener("click", (e) => this.handleClick(e));
      }

      // Handle clicks: If a player clicks an enemy territory, find a neighboring friendly territory to attack from.
      handleClick(event) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        const mousePos = [mouseX, mouseY];

        for (let territory of this.territories) {
          if (!territory.isWater && pointInPolygon(mousePos, territory.polygon)) {
            if (territory.owner !== this.player) {
              for (let neighbor of territory.neighbors) {
                if (neighbor.owner === this.player) {
                  const num = Math.floor(neighbor.population * 0.5);
                  if (num > 0) {
                    neighbor.population -= num;
                    const boat = requiresBoat(neighbor, territory, this.waterTerritories);
                    this.units.push(new Unit(neighbor, territory, num, boat, this.player));
                  }
                  break;
                }
              }
            }
            break;
          }
        }
      }

      // Update units: if a unit reaches its destination, resolve the combat.
      handleUnitArrivals() {
        for (let i = this.units.length - 1; i >= 0; i--) {
          const unit = this.units[i];
          if (unit.progress >= 1) {
            this.resolveAttack(unit);
            this.units.splice(i, 1);
          }
        }
      }

      // Resolve an attack: if attackers outnumber defenders, capture the territory.
      resolveAttack(unit) {
        const target = unit.toTerritory;
        if (unit.number > target.population) {
          target.owner = unit.owner;
          target.population = unit.number - target.population;
        } else {
          target.population -= unit.number;
        }
      }

      // Bot behavior: non-player territories randomly attack adjacent enemy territories.
      botActions() {
        for (let territory of this.territories) {
          if (territory.owner !== this.player && !territory.isWater) {
            for (let neighbor of territory.neighbors) {
              if (neighbor.owner !== territory.owner) {
                if (Math.random() < 0.005) {
                  const num = Math.floor(territory.population * (Math.random() * 0.3 + 0.3));
                  if (num > 0) {
                    territory.population -= num;
                    const boat = requiresBoat(territory, neighbor, this.waterTerritories);
                    this.units.push(new Unit(territory, neighbor, num, boat, territory.owner));
                  }
                }
              }
            }
          }
        }
      }

      update(dt) {
        // Grow the population in each territory.
        for (let territory of this.territories) {
          territory.updatePopulation();
        }
        // Update moving units.
        for (let unit of this.units) {
          unit.update(dt);
        }
        this.handleUnitArrivals();
        // Let bots take their turns.
        this.botActions();
      }

      // Draw all elements on the canvas.
      draw() {
        // Clear the screen with blue (water).
        this.ctx.fillStyle = BLUE;
        this.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        // Draw water territories.
        for (let water of this.waterTerritories) {
          this.drawPolygon(water.polygon, BLUE, BLUE);
        }

        // Draw land territories with border and text labels.
        for (let territory of this.territories) {
          if (territory.isWater) continue;
          const color = TEAM_COLORS[territory.owner] || WHITE;
          this.drawPolygon(territory.polygon, color, BLACK);
          const center = computeCenter(territory.polygon);
          this.ctx.fillStyle = BLACK;
          this.ctx.font = "16px Arial";
          this.ctx.fillText(territory.name, center[0] - 20, center[1] - 30);
          this.ctx.fillText(Math.floor(territory.population).toString(), center[0] - 10, center[1] - 10);
        }

        // Draw moving units (as circles).
        for (let unit of this.units) {
          const start = computeCenter(unit.fromTerritory.polygon);
          const end = computeCenter(unit.toTerritory.polygon);
          const currentX = start[0] + (end[0] - start[0]) * unit.progress;
          const currentY = start[1] + (end[1] - start[1]) * unit.progress;
          this.ctx.beginPath();
          this.ctx.arc(currentX, currentY, unit.isBoat ? 7 : 5, 0, 2 * Math.PI);
          this.ctx.fillStyle = TEAM_COLORS[unit.owner] || BLACK;
          this.ctx.fill();
        }
      }

      // Helper for drawing a filled polygon with border.
      drawPolygon(points, fillColor, strokeColor) {
        this.ctx.beginPath();
        this.ctx.moveTo(points[0][0], points[0][1]);
        for (let i = 1; i < points.length; i++) {
          this.ctx.lineTo(points[i][0], points[i][1]);
        }
        this.ctx.closePath();
        this.ctx.fillStyle = fillColor;
        this.ctx.fill();
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
      }

      // Main game loop using requestAnimationFrame.
      gameLoop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        this.update(dt);
        this.draw();
        requestAnimationFrame((ts) => this.gameLoop(ts));
      }

      run() {
        requestAnimationFrame((ts) => this.gameLoop(ts));
      }
    }

    // ------------------------------
    // Start the Game
    // ------------------------------

    const canvas = document.getElementById("gameCanvas");
    const game = new Game(canvas);
    game.run();
  </script>
</body>
</html>
