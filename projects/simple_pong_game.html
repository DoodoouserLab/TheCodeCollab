<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Territorial: Bots Only</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #202020;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    canvas {
      background-color: #1E1E1E;
      border: 2px solid #333;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <script>
    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Grid setup
    const GRID_WIDTH = 20;
    const GRID_HEIGHT = 20;
    const CELL_SIZE = 30; // Canvas is 600x600, so 20*30

    // Colors
    const COLOR_BG = "#1E1E1E";       // Canvas background color
    const COLOR_GRID = "#323232";     // Grid lines
    const COLOR_PLAYER = "#00FF00";   // Player color (green)
    const COLOR_BOT = "#FF0000";      // Bots color (red)
    const COLOR_NEUTRAL = "#C8C8C8";  // Unclaimed cell color

    // Create grid (2D array): Each cell is either null (unclaimed) or holds an identifier ("player" or "bot_x")
    let grid = [];
    for (let y = 0; y < GRID_HEIGHT; y++) {
      grid[y] = [];
      for (let x = 0; x < GRID_WIDTH; x++) {
        grid[y][x] = null;
      }
    }

    // Entity class for both player and bots
    class Entity {
      constructor(x, y, owner) {
        this.x = x;
        this.y = y;
        this.owner = owner;
      }
      move(dx, dy) {
        const newX = this.x + dx;
        const newY = this.y + dy;
        if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) {
          this.x = newX;
          this.y = newY;
          grid[newY][newX] = this.owner;
        }
      }
    }

    // Create the player in the middle of the grid
    const player = new Entity(Math.floor(GRID_WIDTH / 2), Math.floor(GRID_HEIGHT / 2), "player");
    grid[player.y][player.x] = player.owner;

    // Create bots at random unclaimed cells
    const numBots = 3;
    const bots = [];
    function getRandomCell() {
      return {
        x: Math.floor(Math.random() * GRID_WIDTH),
        y: Math.floor(Math.random() * GRID_HEIGHT)
      };
    }
    for (let i = 0; i < numBots; i++) {
      let pos;
      do {
        pos = getRandomCell();
      } while (grid[pos.y][pos.x] !== null);
      const bot = new Entity(pos.x, pos.y, "bot_" + i);
      bots.push(bot);
      grid[pos.y][pos.x] = bot.owner;
    }

    // Draw the grid and color the cells based on ownership
    function drawGrid() {
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          let color;
          if (grid[y][x] === null) {
            color = COLOR_NEUTRAL;
          } else {
            color = (grid[y][x] === "player") ? COLOR_PLAYER : COLOR_BOT;
          }
          ctx.fillStyle = color;
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          // Draw grid borders for clarity
          ctx.strokeStyle = COLOR_GRID;
          ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
    }

    // Simple random move for bots: chooses one direction (up, down, left, right) and moves if within bounds
    function botMove(bot) {
      const moves = [
        [0, 1],
        [0, -1],
        [1, 0],
        [-1, 0]
      ];
      // Shuffle moves
      for (let i = moves.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [moves[i], moves[j]] = [moves[j], moves[i]];
      }
      // Try each move until a valid one is found
      for (const [dx, dy] of moves) {
        const newX = bot.x + dx;
        const newY = bot.y + dy;
        if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) {
          bot.move(dx, dy);
          break;
        }
      }
    }

    // Count territory for player and bots
    function countTerritory() {
      let playerTerr = 0, botTerr = 0;
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x] === "player") {
            playerTerr++;
          } else if (grid[y][x] !== null) {
            botTerr++;
          }
        }
      }
      return { playerTerr, botTerr };
    }

    // Listen for arrow key presses to move the player
    document.addEventListener("keydown", function(e) {
      switch (e.key) {
        case "ArrowUp":
          player.move(0, -1);
          break;
        case "ArrowDown":
          player.move(0, 1);
          break;
        case "ArrowLeft":
          player.move(-1, 0);
          break;
        case "ArrowRight":
          player.move(1, 0);
          break;
      }
    });

    // Main game loop using setInterval (approx. 5 frames per second, or every 200ms)
    let gameOver = false;
    const gameInterval = setInterval(() => {
      // Each bot makes a move
      bots.forEach(bot => botMove(bot));

      // Clear and redraw the game board
      ctx.fillStyle = COLOR_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawGrid();

      // Update document title with current scores
      const { playerTerr, botTerr } = countTerritory();
      document.title = `Player: ${playerTerr} vs Bots: ${botTerr}`;

      // Check if every cell has been claimed (game over)
      let allClaimed = true;
      outer: for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x] === null) {
            allClaimed = false;
            break outer;
          }
        }
      }

      if (allClaimed) {
        clearInterval(gameInterval);
        gameOver = true;
        let message = `Game Over!\nPlayer territory: ${playerTerr}\nBots territory: ${botTerr}\n`;
        if (playerTerr > botTerr) {
          message += "You win!";
        } else if (playerTerr < botTerr) {
          message += "Bots win!";
        } else {
          message += "It's a tie!";
        }
        alert(message);
      }
    }, 200);
  </script>
</body>
</html>
