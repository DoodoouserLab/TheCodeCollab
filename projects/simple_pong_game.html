<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Territorial – Scandinavia Edition</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid #333;
      background: #1E1E1E;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="800"></canvas>
  <script>
    /***** Configuration *****/
    // Grid parameters – we use a 40×40 grid so that each cell is 20×20 (800×800 canvas)
    const GRID_WIDTH = 40;
    const GRID_HEIGHT = 40;
    const CELL_SIZE = 20;
    const TICK_INTERVAL = 200; // game logic updates every 200ms

    // Colors for various cell types
    const COLOR_NEUTRAL = "#C8C8C8";  // Unclaimed (playable) cell
    const COLOR_PLAYER  = "#00FF00";  // Player’s territory (green)
    const COLOR_BOT     = "#FF0000";  // Bot territory (red)
    const COLOR_INACTIVE = "#111";    // Non-playable (outside the map)

    // Entity movement directions
    const directions = [
      { dx: 0, dy: -1 },
      { dx: 0, dy: 1 },
      { dx: -1, dy: 0 },
      { dx: 1, dy: 0 }
    ];

    /***** Define the Scandinavia Map Polygon *****/
    // These points are specified in grid coordinates (each coordinate refers to a cell unit).
    // Adjust these vertices to change the shape of the playable area.
    const scandinaviaPolygon = [
      { x: 5,  y: 8 },
      { x: 35, y: 8 },
      { x: 38, y: 20 },
      { x: 35, y: 32 },
      { x: 20, y: 37 },
      { x: 5,  y: 32 },
      { x: 2,  y: 20 }
    ];

    // Standard ray-casting algorithm for point-in-polygon.
    function pointInPolygon(x, y, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < ((xj - xi) * (y - yi)) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    /***** Build the Grid *****/
    // Each cell is represented as an object: { owner, playable }.
    // Only cells whose center lies inside scandinaviaPolygon are playable.
    let grid = [];
    for (let y = 0; y < GRID_HEIGHT; y++) {
      grid[y] = [];
      for (let x = 0; x < GRID_WIDTH; x++) {
        // Compute the center of the cell in grid units.
        const cx = x + 0.5;
        const cy = y + 0.5;
        const playable = pointInPolygon(cx, cy, scandinaviaPolygon);
        grid[y][x] = { owner: null, playable: playable };
      }
    }

    /***** Entities: Player & Bots *****/
    // Helper function to pick a random playable cell that is unoccupied.
    function getRandomPlayableCell() {
      let cell;
      do {
        const x = Math.floor(Math.random() * GRID_WIDTH);
        const y = Math.floor(Math.random() * GRID_HEIGHT);
        cell = { x, y };
      } while (!grid[cell.y][cell.x].playable || grid[cell.y][cell.x].owner !== null);
      return cell;
    }

    // Spawn the player.
    // Try to choose a cell near the center of the grid; if it's not playable, use a random one.
    let player;
    if (grid[Math.floor(GRID_HEIGHT / 2)][Math.floor(GRID_WIDTH / 2)].playable) {
      player = { x: Math.floor(GRID_WIDTH / 2), y: Math.floor(GRID_HEIGHT / 2), owner: "player" };
    } else {
      const pos = getRandomPlayableCell();
      player = { x: pos.x, y: pos.y, owner: "player" };
    }
    grid[player.y][player.x].owner = player.owner;

    // Create some bots (e.g., 4 bots)
    const bots = [];
    const NUM_BOTS = 4;
    for (let i = 0; i < NUM_BOTS; i++) {
      const pos = getRandomPlayableCell();
      const bot = { x: pos.x, y: pos.y, owner: "bot_" + i };
      bots.push(bot);
      grid[bot.y][bot.x].owner = bot.owner;
    }

    /***** Canvas Setup *****/
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    /***** Movement Functions *****/
    // Check if the new position is in bounds and playable.
    function canMoveTo(x, y) {
      return x >= 0 && x < GRID_WIDTH &&
             y >= 0 && y < GRID_HEIGHT &&
             grid[y][x].playable;
    }

    // Handle player movement.
    function movePlayer(dx, dy) {
      const newX = player.x + dx;
      const newY = player.y + dy;
      if (canMoveTo(newX, newY)) {
        player.x = newX;
        player.y = newY;
        grid[newY][newX].owner = player.owner;
      }
    }

    // Handle bot movement: choose a random adjacent cell that is playable.
    function moveBot(bot) {
      const validMoves = directions.filter(({dx, dy}) => {
        const nx = bot.x + dx;
        const ny = bot.y + dy;
        return canMoveTo(nx, ny);
      });
      if (validMoves.length === 0) return;
      const move = validMoves[Math.floor(Math.random() * validMoves.length)];
      bot.x += move.dx;
      bot.y += move.dy;
      grid[bot.y][bot.x].owner = bot.owner;
    }

    /***** Game State & Logic *****/
    let gameOver = false;

    // Count territory over all playable cells.
    function countTerritory() {
      let playerTerr = 0;
      let botTerr = 0;
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x].playable && grid[y][x].owner !== null) {
            if (grid[y][x].owner === "player") {
              playerTerr++;
            } else {
              botTerr++;
            }
          }
        }
      }
      return { playerTerr, botTerr };
    }

    // The game advances in ticks.
    function updateGame() {
      // Move each bot.
      bots.forEach(bot => moveBot(bot));
      // Check if all playable cells have been claimed.
      let allClaimed = true;
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x].playable && grid[y][x].owner === null) {
            allClaimed = false;
            break;
          }
        }
        if (!allClaimed) break;
      }
      if (allClaimed) {
        gameOver = true;
      }
    }

    /***** Drawing Functions *****/
    // Draw the grid: each cell’s color depends on its state.
    function drawGrid() {
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          let cell = grid[y][x];
          let fillColor;
          if (!cell.playable) {
            fillColor = COLOR_INACTIVE;
          } else if (cell.owner === "player") {
            fillColor = COLOR_PLAYER;
          } else if (cell.owner && cell.owner.startsWith("bot")) {
            fillColor = COLOR_BOT;
          } else {
            fillColor = COLOR_NEUTRAL;
          }
          ctx.fillStyle = fillColor;
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          // Optionally draw cell borders.
          ctx.strokeStyle = "#333";
          ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
    }

    // Optionally, draw the polygon outline that defines the playable area.
    function drawPolygonOutline() {
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 3;
      ctx.beginPath();
      scandinaviaPolygon.forEach((pt, index) => {
        // Convert grid coordinates to canvas pixels (center of cell)
        const px = (pt.x + 0.5) * CELL_SIZE;
        const py = (pt.y + 0.5) * CELL_SIZE;
        if (index === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      });
      ctx.closePath();
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // Draw the scoreboard overlay.
    function drawScoreboard() {
      const { playerTerr, botTerr } = countTerritory();
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(10, 10, 200, 50);
      ctx.fillStyle = "#fff";
      ctx.font = "16px Arial";
      ctx.fillText("Player: " + playerTerr, 20, 30);
      ctx.fillText("Bots: " + botTerr, 20, 50);
    }

    // Draw the game over overlay.
    function drawGameOver() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);
      ctx.fillStyle = "#fff";
      ctx.font = "40px Arial";
      ctx.textAlign = "center";
      const { playerTerr, botTerr } = countTerritory();
      let message = "Game Over!";
      if (playerTerr > botTerr) {
        message += " You win!";
      } else if (playerTerr < botTerr) {
        message += " Bots win!";
      } else {
        message += " It's a tie!";
      }
      ctx.fillText(message, canvas.width / 2, canvas.height / 2 + 15);
    }

    /***** The Game Loop *****/
    let lastTick = performance.now();
    function gameLoop(timestamp) {
      // Update logic at fixed intervals.
      if (timestamp - lastTick >= TICK_INTERVAL && !gameOver) {
        updateGame();
        lastTick = timestamp;
      }
      // Render the current game state.
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawPolygonOutline();
      drawScoreboard();
      if (!gameOver) {
        requestAnimationFrame(gameLoop);
      } else {
        drawGameOver();
      }
    }
    requestAnimationFrame(gameLoop);

    /***** Player Input *****/
    document.addEventListener("keydown", (e) => {
      if (gameOver) return;
      switch(e.key) {
        case "ArrowUp":
          movePlayer(0, -1);
          break;
        case "ArrowDown":
          movePlayer(0, 1);
          break;
        case "ArrowLeft":
          movePlayer(-1, 0);
          break;
        case "ArrowRight":
          movePlayer(1, 0);
          break;
      }
    });
  </script>
</body>
</html>
