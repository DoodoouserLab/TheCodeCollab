<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Territorial – Scandinavia Edition</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid #333;
      background: #0077be; /* Water color for non-playable cells */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1000" height="1000"></canvas>
  <script>
    /***** CONFIGURATION *****/
    // Grid settings – 50x50 grid gives a 1000×1000 canvas with each cell 20×20.
    const GRID_WIDTH = 50;
    const GRID_HEIGHT = 50;
    const CELL_SIZE = 20;

    // Attack configuration (simulating gradual territorial takeover)
    const ATTACK_FACTOR = 5;      // Each friendly neighbor adds this much progress per tick.
    const ATTACK_THRESHOLD = 100; // When progress reaches this, the cell is captured.
    const TICK_INTERVAL = 200;    // Milliseconds between updates.

    // Colors
    const COLOR_NEUTRAL = "#C8C8C8";  // Unclaimed land cell
    const COLOR_PLAYER  = "#00FF00";  // Player’s territory (green)
    const COLOR_BOT     = "#FF0000";  // Bots’ territory (red)
    const COLOR_WATER   = "#0077be";  // Non‑playable (water)
    
    // We'll use the four cardinal directions.
    const DIRECTIONS = [
      { dx:  0, dy: -1 },  // Up
      { dx:  0, dy:  1 },  // Down
      { dx: -1, dy:  0 },  // Left
      { dx:  1, dy:  0 }   // Right
    ];

    /***** DEFINE THE SCANDINAVIA LAND (PLAYABLE AREA) *****/
    // In Territorial.io the blue part is water. The following polygon (in grid coordinates)
    // approximates a Scandinavian peninsula. Cells whose centers fall inside it are "land."
    const scandinaviaPolygon = [
      { x: 12, y: 4 },  // Top–left
      { x: 38, y: 4 },  // Top–right
      { x: 46, y: 14 }, // East curve
      { x: 44, y: 28 }, // East down
      { x: 36, y: 40 }, // Southeast
      { x: 26, y: 46 }, // South tip
      { x: 16, y: 40 }, // Southwest
      { x: 8,  y: 28 }  // West curve
    ];
    // Standard ray–casting algorithm.
    function pointInPolygon(x, y, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > y) !== (yj > y)) &&
          (x < ((xj - xi) * (y - yi)) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    /***** GRID & CELL SETUP *****/
    // Each cell is an object:
    // { owner: null | "player" | "bot_i", playable: boolean, attack: null | { attacker, progress } }
    let grid = [];
    for (let y = 0; y < GRID_HEIGHT; y++) {
      grid[y] = [];
      for (let x = 0; x < GRID_WIDTH; x++) {
        // Compute the center (in grid units)
        const cx = x + 0.5;
        const cy = y + 0.5;
        const playable = pointInPolygon(cx, cy, scandinaviaPolygon);
        grid[y][x] = {
          owner: null,
          playable: playable,
          attack: null
        };
      }
    }

    /***** INITIALIZE PLAYER & BOTS *****/
    // Helper function: find a random playable cell that is unclaimed.
    function getRandomPlayableCell() {
      let cell;
      do {
        const x = Math.floor(Math.random() * GRID_WIDTH);
        const y = Math.floor(Math.random() * GRID_HEIGHT);
        cell = { x, y };
      } while (!grid[cell.y][cell.x].playable || grid[cell.y][cell.x].owner !== null);
      return cell;
    }

    // Player: try the center of the grid; if not playable, pick random.
    let player;
    if (grid[Math.floor(GRID_HEIGHT / 2)][Math.floor(GRID_WIDTH / 2)].playable) {
      player = { x: Math.floor(GRID_WIDTH / 2), y: Math.floor(GRID_HEIGHT / 2), id: "player" };
    } else {
      player = { ...getRandomPlayableCell(), id: "player" };
    }
    grid[player.y][player.x].owner = player.id;

    // Bots: create (for example) three bots.
    const NUM_BOTS = 3;
    let bots = [];
    for (let i = 0; i < NUM_BOTS; i++) {
      const pos = getRandomPlayableCell();
      const bot = { x: pos.x, y: pos.y, id: "bot_" + i };
      bots.push(bot);
      grid[bot.y][bot.x].owner = bot.id;
    }

    /***** HELPER FUNCTIONS *****/
    // Returns the number of adjacent cells (up, down, left, right) that are owned by "attacker".
    function countFriendlyNeighbors(x, y, attacker) {
      let count = 0;
      for (const {dx, dy} of DIRECTIONS) {
        const nx = x + dx, ny = y + dy;
        if (nx < 0 || nx >= GRID_WIDTH || ny < 0 || ny >= GRID_HEIGHT) continue;
        if (grid[ny][nx].owner === attacker) count++;
      }
      return count;
    }

    // Checks if the given (x, y) is a valid grid coordinate.
    function inBounds(x, y) {
      return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
    }

    /***** PLAYER ATTACK INPUT *****/
    // When arrow keys are pressed, for every border cell that belongs to the player,
    // look in that direction. If the neighbor cell is playable and not already yours,
    // begin (or continue) an attack on that cell.
    function startPlayerAttack(direction) {
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x].owner === "player") {
            const nx = x + direction.dx, ny = y + direction.dy;
            if (!inBounds(nx, ny)) continue;
            const neighbor = grid[ny][nx];
            if (!neighbor.playable) continue; // Cannot attack water.
            if (neighbor.owner === "player") continue; // Already yours.
            // If no attack is ongoing (or if already attacking by player), start/ensure attack.
            if (!neighbor.attack) {
              neighbor.attack = { attacker: "player", progress: 0 };
            } else if (neighbor.attack.attacker === "player") {
              // Optionally boost progress a little on repeated button presses.
              neighbor.attack.progress += 5;
            }
          }
        }
      }
    }

    /***** BOT ATTACK LOGIC *****/
    // For each bot, find one border cell (owned by the bot) and try to attack one neighboring cell.
    function botAttemptAttack(botId) {
      // List of border cells (cells owned by bot that touch at least one cell not owned by bot)
      let borderCells = [];
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x].owner === botId) {
            // Check if any neighbor cell is attackable.
            for (const {dx, dy} of DIRECTIONS) {
              const nx = x + dx, ny = y + dy;
              if (!inBounds(nx, ny)) continue;
              const neighbor = grid[ny][nx];
              if (!neighbor.playable) continue;
              if (neighbor.owner !== botId) {
                borderCells.push({ x, y, dx, dy });
                break;
              }
            }
          }
        }
      }
      if (borderCells.length === 0) return;
      // Choose a random border cell and attempt to attack in its corresponding direction.
      const { dx, dy } = borderCells[Math.floor(Math.random() * borderCells.length)];
      // Now, for every cell owned by this bot, check the neighbor in the (dx,dy) direction.
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x].owner === botId) {
            const nx = x + dx, ny = y + dy;
            if (!inBounds(nx, ny)) continue;
            const neighbor = grid[ny][nx];
            if (!neighbor.playable) continue;
            if (neighbor.owner === botId) continue;
            if (!neighbor.attack) {
              neighbor.attack = { attacker: botId, progress: 0 };
              // To limit one attack per bot per update cycle:
              return;
            }
          }
        }
      }
    }

    /***** GAME UPDATE *****/
    let gameOver = false;
    let lastTick = performance.now();
    function updateGame(deltaTime) {
      // First, update all ongoing attacks.
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          const cell = grid[y][x];
          if (cell.attack !== null) {
            // Calculate support: the number of adjacent cells owned by the attacker.
            let support = countFriendlyNeighbors(x, y, cell.attack.attacker);
            // Increase progress based on support.
            cell.attack.progress += support * ATTACK_FACTOR;
            if (cell.attack.progress >= ATTACK_THRESHOLD) {
              cell.owner = cell.attack.attacker;
              cell.attack = null;
            }
          }
        }
      }
      // Let bots attempt attacks.
      bots.forEach(bot => {
        botAttemptAttack(bot.id);
      });
      
      // Check for game end: if every playable cell is claimed.
      let allClaimed = true;
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x].playable && grid[y][x].owner === null) {
            allClaimed = false;
            break;
          }
        }
        if (!allClaimed) break;
      }
      if (allClaimed) gameOver = true;
    }

    /***** RENDERING *****/
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    function drawGrid() {
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          const cell = grid[y][x];
          let fillColor;
          if (!cell.playable) {
            fillColor = COLOR_WATER;
          } else if (cell.owner === "player") {
            fillColor = COLOR_PLAYER;
          } else if (cell.owner && cell.owner.startsWith("bot")) {
            fillColor = COLOR_BOT;
          } else {
            fillColor = COLOR_NEUTRAL;
          }
          // Draw the cell.
          ctx.fillStyle = fillColor;
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);

          // If the cell is under attack, overlay a translucent white showing progress.
          if (cell.attack) {
            const progressRatio = Math.min(cell.attack.progress / ATTACK_THRESHOLD, 1);
            ctx.fillStyle = "rgba(255, 255, 255," + (progressRatio * 0.6) + ")";
            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          }
          // Optional: Draw grid borders.
          ctx.strokeStyle = "#333";
          ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
    }

    // Draw the polygon border of the Scandinavian land.
    function drawPolygonOutline() {
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 3;
      ctx.beginPath();
      scandinaviaPolygon.forEach((pt, index) => {
        // Convert grid coordinate to canvas pixel (center of cell)
        const px = (pt.x + 0.5) * CELL_SIZE;
        const py = (pt.y + 0.5) * CELL_SIZE;
        if (index === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      });
      ctx.closePath();
      ctx.stroke();
      ctx.lineWidth = 1;
    }

    // Draw a scoreboard overlay.
    function drawScoreboard() {
      let playerCount = 0, botCount = 0;
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x].playable && grid[y][x].owner) {
            if (grid[y][x].owner === "player") playerCount++;
            else botCount++;
          }
        }
      }
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(10, 10, 220, 50);
      ctx.fillStyle = "#fff";
      ctx.font = "16px Arial";
      ctx.fillText("Player: " + playerCount, 20, 30);
      ctx.fillText("Bots: " + botCount, 20, 50);
    }

    // Draw game over overlay.
    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.8)";
      ctx.fillRect(0, canvas.height/2 - 50, canvas.width, 100);
      ctx.fillStyle = "#fff";
      ctx.font = "40px Arial";
      ctx.textAlign = "center";
      let playerCount = 0, botCount = 0;
      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          if (grid[y][x].playable && grid[y][x].owner)
