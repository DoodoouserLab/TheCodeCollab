<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>little game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden; /* no scrollbars */
    }
    canvas {
      display: block;
      width: 100vw;   /* full viewport width */
      height: 100vh;  /* full viewport height */
      touch-action: none; /* disable default touch gestures */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <script>

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    const targetArena = { x: 0, y: 0 };
    const drawingRatio = { x: 0, y: 0 };
    const GRID_W = 20; // horizontal
    const GRID_H = 30; // vertical

    targetArena.y = canvas.height * 0.8;
    targetArena.x = targetArena.y * (GRID_W / GRID_H); // 0.75
    drawingRatio.x = targetArena.x / GRID_W;
    drawingRatio.y = targetArena.y / GRID_H;

    function toCanvasXY(gx, gy) {
      return {
        x: (canvas.width - targetArena.x)/2 + gx * drawingRatio.x,
        y:    0.1 * canvas.height   + gy * drawingRatio.y
      };
    }


    const arenaImage = new Image();
    arenaImage.src = "./images/arena.png"; // your file path

    
    let yourClash = new Map();

    let enemyClash = new Map();

    function getDistance(x1, y1, x2, y2) {
      const dx = x1 - x2;
      const dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Generic: find closest unit in a given map
    function findClosestInMap(myX, myY, targetMap) {
      let closest = null;
      let minDistance = Infinity;
    
      for (const [name, unit] of targetMap.entries()) {
        const distance = getDistance(myX, myY, unit.x, unit.y);
        if (distance < minDistance) {
          minDistance = distance;
          closest = { name, enemy: unit, distance };
        }
      }
      return closest;
    }
    
    function moveToward(myClan, target, step) {
      const dx = target.enemy.x - myClan.x;
      const dy = target.enemy.y - myClan.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance > step) {
      myClan.x += (dx / distance) * step;
      myClan.y += (dy / distance) * step;
      } else {
        myClan.x = target.enemy.x;
        myClan.y = target.enemy.y;
      }
      
        // clamp to grid bounds
      if (myClan.x < 0) myClan.x = 0;
      if (myClan.y < 0) myClan.y = 0;
      if (myClan.x > GRID_W) myClan.x = GRID_W;
      if (myClan.y > GRID_H) myClan.y = GRID_H;
    }

    
    function checkDamageFromMap(myClan, attackersMap) {
      for (const attacker of attackersMap.values()) {
        const dist = getDistance(myClan.x, myClan.y, attacker.x, attacker.y);
        if (dist <= attacker.range) {
          myClan.health = Math.max(0, myClan.health - attacker.damage);
        }
      }
    }


    function render(ctx, canvas) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const ax = (canvas.width - targetArena.x) / 2; 
      const ay = 0.1 * canvas.height;
      const aw = targetArena.x;
      const ah = targetArena.y;
    
      // Simple stretch to arena size:
      ctx.drawImage(arenaImage, ax, ay, aw, ah);
        
      for (const clan of yourClash.values()) {
        const { x: px, y: py } = toCanvasXY(clan.x, clan.y);
        const rx = drawingRatio.x;
        const ry = drawingRatio.y;
        if (clan.image && clan.image.complete) {
          ctx.drawImage(clan.image,
            px - rx/2, 
            py - ry/2, 
            rx, 
            ry
          );
        } else {
          ctx.fillStyle = "#3aa";
          ctx.beginPath();
          ctx.arc(px, py, Math.min(drawingRatio.x, drawingRatio.y) * 0.35, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      for (const enemy of enemyClash.values()) {
        const { x: px, y: py } = toCanvasXY(enemy.x, enemy.y);
      
        if (enemy.image && enemy.image.complete) {
          const rx = drawingRatio.x;
          const ry = drawingRatio.y;
          ctx.drawImage(enemy.image,
            px - rx/2, 
            py - ry/2, 
            rx, 
            ry
          );
        } else {
          ctx.fillStyle = "#a33";
          ctx.beginPath();
          ctx.arc(px, py, Math.min(drawingRatio.x, drawingRatio.y) * 0.35, 0, Math.PI * 2);
          ctx.fill();
        }
      }

    }

    
    function gameTick(ctx, canvas) {
      for (const [id, clan] of yourClash.entries()) {
        const closest = findClosestInMap(clan.x, clan.y, enemyClash);
        if (closest) moveToward(clan, closest, clan.speed);
        checkDamageFromMap(clan, enemyClash);
    
        if (clan.health <= 0) {
          clan.image.src = "";
          clan.image = null;
          yourClash.delete(id);
        } else {
          yourClash.set(id, clan);
        }
      }
    
      for (const [id, enemy] of enemyClash.entries()) {
        const closest = findClosestInMap(enemy.x, enemy.y, yourClash);
        if (closest) moveToward(enemy, closest, enemy.speed);
        checkDamageFromMap(enemy, yourClash);
    
        if (enemy.health <= 0) {
          enemy.image.src = "";
          enemy.image = null;
          enemyClash.delete(id);
        } else {
          enemyClash.set(id, enemy);
        }
      }
    
      render(ctx, canvas);
    }

      

      
    
    let unitCounter = 0;

    function Clan(typeThis, xCord, yCord, damageThis, healthThis, speedThis, range, whichClash) {
      this.id = `${typeThis}_${++unitCounter}`;
      this.type = typeThis;
      this.x = xCord;
      this.y = yCord;
      this.damage = damageThis;
      this.range = range;
      this.health = healthThis;
      this.speed = speedThis;
    
      this.image = new Image();
      this.image.src = `./images/${this.type}.png`;
    
      if (whichClash === "your") {
        yourClash.set(this.id, this);
      } else {
        enemyClash.set(this.id, this);
      }
    }

    
    new Clan("knight", 0, 5, 10, 100, 0.3, 0.03, "your");
    new Clan("knight", 8, 8, 6, 80, 0.4, 0.06, "your");
    new Clan("knight", 12, 20, 8, 90, 0.02, 4, "enemy");
    new Clan("knight", 16, 26, 5, 60, 0.03, 3, "enemy");


    function loop() {
      gameTick(ctx, canvas);
      requestAnimationFrame(loop);
    }
    Promise.all([
      // all unit images
      ...[...yourClash.values(), ...enemyClash.values()].map(u =>
        new Promise(res => {
          u.image.onload  = res;
          u.image.onerror = res;
        })
      ),
      // the arena background
      new Promise(res => {
        arenaImage.onload  = res;
        arenaImage.onerror = res;
      })
    ]).then(loop);



    function resize() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
      targetArena.y = canvas.height * 0.8;
      targetArena.x = targetArena.y * (GRID_W / GRID_H);
      drawingRatio.x = targetArena.x / GRID_W;
      drawingRatio.y = targetArena.y / GRID_H;
    }

    window.addEventListener("resize", resize);
    resize();

    
  </script>
</body>
</html>
