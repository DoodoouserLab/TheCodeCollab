<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>little game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden; /* no scrollbars */
    }
    canvas {
      display: block;
      width: 100vw;   /* full viewport width */
      height: 100vh;  /* full viewport height */
      touch-action: none; /* disable default touch gestures */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <script>

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    
    
    let yourClash = new Map();

    let enemyClash = new Map();

    function getDistance(x1, y1, x2, y2) {
      const dx = x1 - x2;
      const dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Generic: find closest unit in a given map
    function findClosestInMap(myX, myY, targetMap) {
      let closest = null;
      let minDistance = Infinity;
    
      for (const [name, unit] of targetMap.entries()) {
        const distance = getDistance(myX, myY, unit.x, unit.y);
        if (distance < minDistance) {
          minDistance = distance;
          closest = { name, enemy: unit, distance };
        }
      }
      return closest;
    }
    
    function moveToward(myClan, target, step) {
      
      const dx = target.enemy.x - myClan.x;
      const dy = target.enemy.y - myClan.y;
      const distance = Math.sqrt(dx * dx + dy * dy); // fixed parenthesis
    
      if (distance > step) {
        if (myClan.x > 20 || myClan.x
        myClan.x += (dx / distance) * step;
        myClan.y += (dy / distance) * step;
      } else {
        // snap to target position
        myClan.x = target.enemy.x;
        myClan.y = target.enemy.y;
      }
    }
    
    function checkDamageFromMap(myClan, attackersMap) {
      for (const attacker of attackersMap.values()) {
        const dist = getDistance(myClan.x, myClan.y, attacker.x, attacker.y);
        if (dist <= attacker.range) {
          myClan.health = Math.max(0, myClan.health - attacker.damage);
        }
      }
    }


    function render(ctx, canvas) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    
      // Draw your units
      for (const clan of yourClash.values()) {
        if (clan.image && clan.image.complete) {
          ctx.drawImage(clan.image,
            clan.x - clan.image.width  / 2,
            clan.y - clan.image.height / 2
          );

        } else {
          // fallback: draw a circle
          ctx.fillStyle = "#3aa";
          ctx.beginPath();
          ctx.arc(clan.x, clan.y, 8, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    
      // Draw enemies
      for (const enemy of enemyClash.values()) {
        if (enemy.image && enemy.image.complete) {
          ctx.drawImage(enemy.image,
              enemy.x - enemy.image.width / 2,
              enemy.y - enemy.image.height / 2
          );
        } else {
          ctx.fillStyle = "#a33";
          ctx.beginPath();
          ctx.arc(enemy.x, enemy.y, 8, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    
    function gameTick(ctx, canvas) {
      for (const [id, clan] of yourClash.entries()) {
        const closest = findClosestInMap(clan.x, clan.y, enemyClash);
        if (closest) moveToward(clan, closest, clan.speed);
        checkDamageFromMap(clan, enemyClash);
    
        if (clan.health <= 0) {
          clan.image.src = "";
          clan.image = null;
          yourClash.delete(id);
        } else {
          yourClash.set(id, clan);
        }
      }
    
      for (const [id, enemy] of enemyClash.entries()) {
        const closest = findClosestInMap(enemy.x, enemy.y, yourClash);
        if (closest) moveToward(enemy, closest, enemy.speed);
        checkDamageFromMap(enemy, yourClash);
    
        if (enemy.health <= 0) {
          enemy.image.src = "";
          enemy.image = null;
          enemyClash.delete(id);
        } else {
          enemyClash.set(id, enemy);
        }
      }
    
      render(ctx, canvas);
    }

      

      
    
    let unitCounter = 0;

    function Clan(typeThis, xCord, yCord, damageThis, healthThis, speedThis, range, whichClash) {
      this.id = `${typeThis}_${++unitCounter}`;
      this.type = typeThis;
      this.x = xCord;
      this.y = yCord;
      this.damage = damageThis;
      this.range = range;
      this.health = healthThis;
      this.speed = speedThis;
    
      this.image = new Image();
      this.image.src = `./images/${this.type}.png`;
    
      if (whichClash === "your") {
        yourClash.set(this.id, this);
      } else {
        enemyClash.set(this.id, this);
      }
    }

    
    new Clan("knight", 50, 50, 10, 100, 3, 30, "your");
    new Clan("knight", 80, 80, 6, 80, 4, 60, "your");
    new Clan("knight", 300, 200, 8, 90, 2, 40, "enemy");
    new Clan("knight", 350, 260, 5, 60, 3, 30, "enemy");


    function loop() {
      gameTick(ctx, canvas);
      requestAnimationFrame(loop);
    }
    
    Promise.all(
      [...yourClash.values(), ...enemyClash.values()]
        .map(u => new Promise(r => {
          u.image.onload = r;
          u.image.onerror = r;
        }))
    ).then(() => loop());


    function resize() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
      targetArena.y = canvas.height * 0.8;
      targetArena.x = targetArena.y * 0.75;
      drawingRatio.x = targetArena.x / 20;
      drawingRatio.y = targetarena.y / 30;
    }
    window.addEventListener("resize", resize);
    resize();

    
  </script>
</body>
</html>
