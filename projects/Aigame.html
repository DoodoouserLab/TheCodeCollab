<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Cube â€“ No Libraries</title>
  <style>
    /* Make sure the canvas fills the screen */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: #000;
    }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>
  <script>
    // Get the canvas and initialize a WebGL context.
    const canvas = document.getElementById("glCanvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const gl = canvas.getContext("webgl");
    if (!gl) {
      alert("WebGL not supported in this browser.");
    }

    // --- Shader Source Code ---
    const vsSource = `
      attribute vec3 aPosition;
      attribute vec3 aColor;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      varying vec3 vColor;
      void main(void) {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
        vColor = aColor;
      }
    `;

    const fsSource = `
      precision mediump float;
      varying vec3 vColor;
      void main(void) {
        gl_FragColor = vec4(vColor, 1.0);
      }
    `;

    // --- Shader Compilation Helper Functions ---
    function loadShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function initShaderProgram(vsSource, fsSource) {
      const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
        return null;
      }
      return shaderProgram;
    }

    const shaderProgram = initShaderProgram(vsSource, fsSource);
    gl.useProgram(shaderProgram);

    // --- Look Up Locations ---
    const programInfo = {
      attribLocations: {
        vertexPosition: gl.getAttribLocation(shaderProgram, 'aPosition'),
        vertexColor: gl.getAttribLocation(shaderProgram, 'aColor')
      },
      uniformLocations: {
        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')
      }
    };

    // --- Cube Geometry Data ---
    const positions = [
      // Front face
      -1.0, -1.0,  1.0,
       1.0, -1.0,  1.0,
       1.0,  1.0,  1.0,
      -1.0,  1.0,  1.0,
      // Back face
      -1.0, -1.0, -1.0,
      -1.0,  1.0, -1.0,
       1.0,  1.0, -1.0,
       1.0, -1.0, -1.0,
      // Top face
      -1.0,  1.0, -1.0,
      -1.0,  1.0,  1.0,
       1.0,  1.0,  1.0,
       1.0,  1.0, -1.0,
      // Bottom face
      -1.0, -1.0, -1.0,
       1.0, -1.0, -1.0,
       1.0, -1.0,  1.0,
      -1.0, -1.0,  1.0,
      // Right face
       1.0, -1.0, -1.0,
       1.0,  1.0, -1.0,
       1.0,  1.0,  1.0,
       1.0, -1.0,  1.0,
      // Left face
      -1.0, -1.0, -1.0,
      -1.0, -1.0,  1.0,
      -1.0,  1.0,  1.0,
      -1.0,  1.0, -1.0,
    ];

    // Each face gets a solid color.
    const faceColors = [
      [1.0, 0.0, 0.0], // Front: red
      [0.0, 1.0, 0.0], // Back: green
      [0.0, 0.0, 1.0], // Top: blue
      [1.0, 1.0, 0.0], // Bottom: yellow
      [1.0, 0.0, 1.0], // Right: magenta
      [0.0, 1.0, 1.0]  // Left: cyan
    ];

    let colors = [];
    for (let i = 0; i < faceColors.length; i++) {
      const c = faceColors[i];
      // Repeat once for each of the face's 4 vertices.
      for (let j = 0; j < 4; j++) {
        colors.push(c[0], c[1], c[2]);
      }
    }

    // Define the indices for the cube (2 triangles per face)
    const indices = [
      0, 1, 2,    0, 2, 3,      // Front face
      4, 5, 6,    4, 6, 7,      // Back face
      8, 9, 10,   8, 10, 11,    // Top face
      12, 13, 14, 12, 14, 15,    // Bottom face
      16, 17, 18, 16, 18, 19,    // Right face
      20, 21, 22, 20, 22, 23     // Left face
    ];

    // --- Create and Bind Buffers ---
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition,
                           3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.vertexAttribPointer(programInfo.attribLocations.vertexColor,
                           3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);

    // --- Matrix Utility Functions (Column-Major Order) ---
    function identity() {
      return [
         1, 0, 0, 0,
         0, 1, 0, 0,
         0, 0, 1, 0,
         0, 0, 0, 1
      ];
    }

    // Multiply two 4x4 matrices (both in column-major order)
    function multiplyMatrix(a, b) {
      let out = new Array(16);
      for (let j = 0; j < 4; j++) {
        for (let i = 0; i < 4; i++) {
          out[i + j * 4] =
            a[i + 0 * 4] * b[0 + j * 4] +
            a[i + 1 * 4] * b[1 + j * 4] +
            a[i + 2 * 4] * b[2 + j * 4] +
            a[i + 3 * 4] * b[3 + j * 4];
        }
      }
      return out;
    }

    // Perspective matrix (column-major)
    function perspective(fov, aspect, near, far) {
      const f = 1.0 / Math.tan(fov / 2);
      return [
         f / aspect, 0,                       0,  0,
         0,          f,                       0,  0,
         0,          0,   (far + near) / (near - far), -1,
         0,          0, (2 * far * near) / (near - far),  0
      ];
    }

    // Translation matrix (column-major)
    function translate(tx, ty, tz) {
      return [
         1, 0, 0, 0,
         0, 1, 0, 0,
         0, 0, 1, 0,
         tx, ty, tz, 1
      ];
    }

    // Rotation around the X axis.
    function rotateX(angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      return [
        1,  0,  0, 0,
        0,  c,  s, 0,
        0, -s,  c, 0,
        0,  0,  0, 1
      ];
    }

    // Rotation around the Y axis.
    function rotateY(angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      return [
         c, 0, -s, 0,
         0, 1,  0, 0,
         s, 0,  c, 0,
         0, 0,  0, 1
      ];
    }

    // --- Animation Loop ---
    let previousTime = 0;
    let angle = 0;
    function render(currentTime) {
      currentTime *= 0.001; // convert to seconds
      const deltaTime = currentTime - previousTime;
      previousTime = currentTime;
      angle += deltaTime;

      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clearDepth(1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Build the projection matrix.
      const fieldOfView = 60 * Math.PI / 180; // in radians
      const aspect = canvas.width / canvas.height;
      const projMatrix = perspective(fieldOfView, aspect, 0.1, 100.0);

      // Build the model-view matrix:
      // 1. Translate away from the camera.
      // 2. Apply rotations.
      let modelMatrix = identity();
      modelMatrix = multiplyMatrix(modelMatrix, translate(0, 0, -6));
      modelMatrix = multiplyMatrix(modelMatrix, rotateY(angle));
      modelMatrix = multiplyMatrix(modelMatrix, rotateX(angle * 0.7));

      // Send the matrices to the shader.
      gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix,
                          false, new Float32Array(projMatrix));
      gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix,
                          false, new Float32Array(modelMatrix));

      // Draw the cube.
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>
</html>
