<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mini Minecraft Clone</title>
  <style>
    /* Center the canvas and give it a border */
    canvas {
      border: 1px solid black;
      display: block;
      margin: 20px auto;
      background-color: #87CEEB; /* A sky-blue background */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="960" height="640"></canvas>

  <script>
    /**************************************
     * Configuration and World Generation *
     **************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Define block size and world dimensions (in blocks)
    const BLOCK_SIZE = 32;
    const WORLD_WIDTH = canvas.width / BLOCK_SIZE;   // e.g., 30 columns
    const WORLD_HEIGHT = canvas.height / BLOCK_SIZE;   // e.g., 20 rows

    // World grid: 0 represents air, 1 represents a solid block.
    let world = [];
    for (let y = 0; y < WORLD_HEIGHT; y++) {
      world[y] = [];
      for (let x = 0; x < WORLD_WIDTH; x++) {
        // Bottom three rows are "ground" while the rest is air.
        if (y > WORLD_HEIGHT - 4) {
          world[y][x] = 1;
        } else {
          world[y][x] = 0;
        }
      }
    }

    // Add a few random floating blocks for variety.
    for (let i = 0; i < 20; i++) {
      let rx = Math.floor(Math.random() * WORLD_WIDTH);
      let ry = Math.floor(Math.random() * (WORLD_HEIGHT - 5));
      world[ry][rx] = 1;
    }

    /**********************
     * Player Definition  *
     **********************/
    const player = {
      x: BLOCK_SIZE * 2,               // Starting x (in pixels)
      y: canvas.height - BLOCK_SIZE * 5, // Starting y above the ground
      width: 20,
      height: 30,
      vx: 0,
      vy: 0,
      speed: 2,
      jumpStrength: -8,
      onGround: false
    };

    // Object to keep track of key states.
    let keys = {};
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
    });
    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    /******************************************
     * Mouse Interaction for Block Editing    *
     ******************************************/
    // Prevent the browserâ€™s context menu on right click.
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // When the canvas is clicked, determine which block cell is affected.
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const cellX = Math.floor(mouseX / BLOCK_SIZE);
      const cellY = Math.floor(mouseY / BLOCK_SIZE);

      // Left click (button 0) mines a block.
      if (e.button === 0) {
        if (cellX >= 0 && cellX < WORLD_WIDTH && cellY >= 0 && cellY < WORLD_HEIGHT) {
          if (world[cellY][cellX] === 1) {
            world[cellY][cellX] = 0;
          }
        }
      }
      // Right click (button 2) places a block,
      // unless the cell is where the player's center is.
      else if (e.button === 2) {
        if (cellX >= 0 && cellX < WORLD_WIDTH && cellY >= 0 && cellY < WORLD_HEIGHT) {
          const playerCellX = Math.floor((player.x + player.width / 2) / BLOCK_SIZE);
          const playerCellY = Math.floor((player.y + player.height / 2) / BLOCK_SIZE);
          if (!(cellX === playerCellX && cellY === playerCellY)) {
            world[cellY][cellX] = 1;
          }
        }
      }
    });

    /*************************
     * Collision Detection   *
     *************************/
    // Simple axis-aligned bounding box intersection.
    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
      return !(x1 + w1 <= x2 ||
               x1 >= x2 + w2 ||
               y1 + h1 <= y2 ||
               y1 >= y2 + h2);
    }

    // Check if moving the player to (newX, newY) would collide with any solid blocks.
    function checkCollision(newX, newY) {
      const startCol = Math.floor(newX / BLOCK_SIZE);
      const endCol = Math.floor((newX + player.width) / BLOCK_SIZE);
      const startRow = Math.floor(newY / BLOCK_SIZE);
      const endRow = Math.floor((newY + player.height) / BLOCK_SIZE);
      
      for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
          if (row >= 0 && row < WORLD_HEIGHT && col >= 0 && col < WORLD_WIDTH) {
            if (world[row][col] === 1) {
              if (rectIntersect(newX, newY, player.width, player.height, col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }

    /************************
     * Player Physics Update *
     ************************/
    // Apply input, gravity and resolve collisions.
    const gravity = 0.4;
    function updatePlayer() {
      // Horizontal movement
      if (keys["ArrowLeft"] || keys["KeyA"]) {
        player.vx = -player.speed;
      } else if (keys["ArrowRight"] || keys["KeyD"]) {
        player.vx = player.speed;
      } else {
        player.vx = 0;
      }

      // Jump when on the ground.
      if ((keys["ArrowUp"] || keys["KeyW"] || keys["Space"]) && player.onGround) {
        player.vy = player.jumpStrength;
        player.onGround = false;
      }

      // Apply gravity
      player.vy += gravity;

      // Attempt horizontal move
      let newX = player.x + player.vx;
      if (!checkCollision(newX, player.y)) {
        player.x = newX;
      } else {
        player.vx = 0;  // simple collision response
      }

      // Attempt vertical move
      let newY = player.y + player.vy;
      if (!checkCollision(player.x, newY)) {
        player.y = newY;
        player.onGround = false;
      } else {
        // If falling, place the player neatly on top of the block.
        if (player.vy > 0) {
          const row = Math.floor((player.y + player.height) / BLOCK_SIZE);
          player.y = row * BLOCK_SIZE - player.height;
          player.onGround = true;
        } 
        // If moving upward, adjust downward.
        else if (player.vy < 0) {
          const row = Math.floor(player.y / BLOCK_SIZE);
          player.y = (row + 1) * BLOCK_SIZE;
        }
        player.vy = 0;
      }
    }

    /*********************
     * Rendering Routine *
     *********************/
    function draw() {
      // Clear the canvas.
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw world blocks.
      for (let y = 0; y < WORLD_HEIGHT; y++) {
        for (let x = 0; x < WORLD_WIDTH; x++) {
          if (world[y][x] === 1) {
            ctx.fillStyle = "#8B4513"; // Brown color for blocks (dirt/stone)
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = "black";
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }

      // Draw the player as a red rectangle.
      ctx.fillStyle = "red";
      ctx.fillRect(player.x, player.y, player.width, player.height);
    }

    /***************
     * Game Loop   *
     ***************/
    function gameLoop() {
      updatePlayer();
      draw();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>
