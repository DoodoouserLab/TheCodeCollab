<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini Terraria â€“ Fixed Movement & Extra Mining</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #87CEEB;
    }
    canvas {
      display: block;
      background: #87CEEB;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    /***** Canvas Setup *****/
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    /***** World Generation *****/
    const tileSize = 16;      // Each block is 16x16 pixels
    const worldWidth = 200;   // Horizontal block count
    const worldHeight = 100;  // Vertical block count

    // Block Types:
    // 0: Air, 1: Dirt, 2: Stone, 3: Grass, 4: Wood, 5: Leaves
    const world = [];
    for (let x = 0; x < worldWidth; x++) {
      world[x] = [];
      // Use a sine wave plus some randomness to determine the ground height.
      let groundHeight = Math.floor(30 + 10 * Math.sin(x * 0.2) + (Math.random() * 5 - 2.5));
      for (let y = 0; y < worldHeight; y++) {
        if (y > groundHeight) {
          // Underground: mix dirt and stone.
          world[x][y] = (Math.random() < 0.2) ? 1 : 2;
        } else if (y === groundHeight) {
          world[x][y] = 3; // Grass on the surface.
        } else {
          world[x][y] = 0; // Air above.
        }
      }
    }
    // Simple tree generation on grass blocks.
    for (let x = 5; x < worldWidth - 5; x++) {
      for (let y = 0; y < worldHeight; y++) {
        if (world[x][y] === 3 && Math.random() < 0.03) {
          let treeHeight = 3 + Math.floor(Math.random() * 3); // Trunk: 3-5 blocks tall.
          for (let t = 1; t <= treeHeight; t++) {
            if (y - t >= 0) {
              world[x][y - t] = 4; // Wood trunk.
            }
          }
          let topY = y - treeHeight;
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              if (x + dx >= 0 && x + dx < worldWidth && topY + dy >= 0) {
                if (Math.random() < 0.7) {
                  world[x + dx][topY + dy] = 5; // Leaves.
                }
              }
            }
          }
        }
      }
    }
    const blockColors = {
      0: "#87CEEB", // Air (sky blue)
      1: "#8B4513", // Dirt
      2: "#808080", // Stone
      3: "#228B22", // Grass
      4: "#A0522D", // Wood
      5: "#32CD32"  // Leaves
    };

    /***** Block Durability *****/
    // Each block type requires multiple hits to break.
    const blockDurability = {
      1: 2, // Dirt
      2: 3, // Stone
      3: 2, // Grass
      4: 3, // Wood
      5: 1  // Leaves
    };
    // Create a parallel 2D array for tracking block health.
    const blockHealth = [];
    for (let x = 0; x < worldWidth; x++) {
      blockHealth[x] = [];
      for (let y = 0; y < worldHeight; y++) {
        let block = world[x][y];
        blockHealth[x][y] = (block !== 0 && blockDurability[block] !== undefined)
                              ? blockDurability[block]
                              : 0;
      }
    }

    /***** Player Setup *****/
    const player = {
      x: 50, // In world coordinates.
      y: 20,
      width: tileSize,
      height: tileSize * 1.8,
      vx: 0,
      vy: 0,
      speed: 2,
      jumpStrength: 8,
      grounded: false,
      health: 100,
      inventory: { dirt: 0, stone: 0, grass: 0, wood: 0, leaves: 0 }
    };

    /***** Enemy Setup *****/
    const enemies = [];
    function spawnEnemy(x, y) {
      enemies.push({
        x: x,
        y: y,
        width: tileSize,
        height: tileSize,
        vx: 0,
        vy: 0,
        speed: 0.5,
        grounded: false,
        health: 20,
        type: "slime"
      });
    }
    // Spawn a few enemy slimes near the surface.
    for (let i = 0; i < 5; i++) {
      let ex = Math.floor(Math.random() * (worldWidth - 20)) + 10;
      let ey = 0;
      for (let y = 0; y < worldHeight; y++) {
        if (world[ex][y] !== 0) {
          ey = y - 1;
          break;
        }
      }
      spawnEnemy(ex * tileSize, ey * tileSize);
    }

    /***** Input Handling *****/
    const keys = {};
    window.addEventListener("keydown", e => { keys[e.key] = true; });
    window.addEventListener("keyup", e => { keys[e.key] = false; });

    /***** Helper Functions *****/
    function isSolid(block) {
      return block !== 0;
    }
    function getBlock(x, y) {
      if (x < 0 || x >= worldWidth || y < 0 || y >= worldHeight) return 0;
      return world[x][y];
    }
    function setBlock(x, y, block) {
      if (x < 0 || x >= worldWidth || y < 0 || y >= worldHeight) return;
      world[x][y] = block;
      if (block !== 0 && blockDurability[block] !== undefined) {
        blockHealth[x][y] = blockDurability[block];
      } else {
        blockHealth[x][y] = 0;
      }
    }
    function checkCollision(a, b) {
      return (a.x < b.x + b.width &&
              a.x + a.width > b.x &&
              a.y < b.y + b.height &&
              a.y + a.height > b.y);
    }

    // NEW: Incremental collision detection for smoother movement.
    // We move the entity in small steps along each axis, checking for collisions.
    function isColliding(entity) {
      let leftTile = Math.floor(entity.x / tileSize);
      let rightTile = Math.floor((entity.x + entity.width) / tileSize);
      let topTile = Math.floor(entity.y / tileSize);
      let bottomTile = Math.floor((entity.y + entity.height) / tileSize);
      for (let x = leftTile; x <= rightTile; x++) {
        for (let y = topTile; y <= bottomTile; y++) {
          if (isSolid(getBlock(x, y))) {
            return true;
          }
        }
      }
      return false;
    }

    function updateEntityPhysics(entity) {
      // Horizontal movement using incremental steps.
      let steps = Math.ceil(Math.abs(entity.vx));
      let moveX = steps === 0 ? 0 : entity.vx / steps;
      for (let i = 0; i < steps; i++) {
        entity.x += moveX;
        if (isColliding(entity)) {
          entity.x -= moveX;
          entity.vx = 0;
          break;
        }
      }
      // Vertical movement using incremental steps.
      steps = Math.ceil(Math.abs(entity.vy));
      let moveY = steps === 0 ? 0 : entity.vy / steps;
      entity.grounded = false;
      for (let i = 0; i < steps; i++) {
        entity.y += moveY;
        if (isColliding(entity)) {
          entity.y -= moveY;
          if (moveY > 0) entity.grounded = true;
          entity.vy = 0;
          break;
        }
      }
    }

    /***** Player Update *****/
    function updatePlayer() {
      // Horizontal input.
      if (keys["a"] || keys["ArrowLeft"]) {
        player.vx = -player.speed;
      } else if (keys["d"] || keys["ArrowRight"]) {
        player.vx = player.speed;
      } else {
        player.vx = 0;
      }
      // Jumping.
      if ((keys["w"] || keys["ArrowUp"] || keys[" "]) && player.grounded) {
        player.vy = -player.jumpStrength;
        player.grounded = false;
      }
      // Apply gravity.
      player.vy += 0.4;
      updateEntityPhysics(player);
    }

    /***** Enemy Update *****/
    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        let enemy = enemies[i];
        // Basic AI: if within 300px horizontally, move toward the player.
        if (Math.abs(enemy.x - player.x) < 300) {
          enemy.vx = enemy.x < player.x ? enemy.speed : -enemy.speed;
        } else {
          enemy.vx += (Math.random() - 0.5) * 0.2;
          if (enemy.vx > enemy.speed) enemy.vx = enemy.speed;
          if (enemy.vx < -enemy.speed) enemy.vx = -enemy.speed;
        }
        enemy.vy += 0.4;
        updateEntityPhysics(enemy);
        // Damage the player if colliding.
        if (checkCollision(enemy, player)) {
          player.health -= 0.2;
        }
        if (enemy.health <= 0) {
          enemies.splice(i, 1);
        }
      }
    }

    /***** Enhanced Mining Mechanic *****/
    // Each click applies fixed damage to a block; multiple clicks are required to break a block.
    const miningDamage = 1;
    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      // Determine the camera offset (same as in rendering).
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      let blockX = Math.floor((mouseX + camX) / tileSize);
      let blockY = Math.floor((mouseY + camY) / tileSize);
      // Only allow mining if within roughly 5 tiles.
      const playerTileX = Math.floor(player.x / tileSize);
      const playerTileY = Math.floor(player.y / tileSize);
      const dx = blockX - playerTileX;
      const dy = blockY - playerTileY;
      if (dx * dx + dy * dy <= 25) {
        const blockId = getBlock(blockX, blockY);
        if (isSolid(blockId) && blockDurability[blockId] !== undefined) {
          blockHealth[blockX][blockY] -= miningDamage;
          if (blockHealth[blockX][blockY] <= 0) {
            switch (blockId) {
              case 1: player.inventory.dirt++; break;
              case 2: player.inventory.stone++; break;
              case 3: player.inventory.grass++; break;
              case 4: player.inventory.wood++; break;
              case 5: player.inventory.leaves++; break;
            }
            setBlock(blockX, blockY, 0);
          }
        }
      }
    });

    /***** Day/Night Cycle *****/
    let timeCounter = 0;
    const dayCycle = 6000; // Frames per full day cycle.
    function updateTime() {
      timeCounter = (timeCounter + 1) % dayCycle;
    }

    /***** Render Function *****/
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Basic camera centering on the player (clamped to world bounds).
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      camX = Math.max(0, Math.min(camX, worldWidth * tileSize - canvas.width));
      camY = Math.max(0, Math.min(camY, worldHeight * tileSize - canvas.height));

      // Render world blocks.
      for (let x = 0; x < worldWidth; x++) {
        for (let y = 0; y < worldHeight; y++) {
          const block = world[x][y];
          if (block !== 0) {
            ctx.fillStyle = blockColors[block];
            ctx.fillRect(x * tileSize - camX, y * tileSize - camY, tileSize, tileSize);
            // Draw red overlay if the block is partially mined.
            if (blockDurability[block] !== undefined) {
              const maxHP = blockDurability[block];
              const currentHP = blockHealth[x][y];
              if (currentHP < maxHP) {
                const damagePercent = (maxHP - currentHP) / maxHP;
                ctx.fillStyle = "rgba(255, 0, 0, " + damagePercent + ")";
                ctx.fillRect(x * tileSize - camX, y * tileSize - camY, tileSize, tileSize);
              }
            }
          }
        }
      }

      // Render enemies.
      for (let enemy of enemies) {
        ctx.fillStyle = "#00FF00";
        ctx.fillRect(enemy.x - camX, enemy.y - camY, enemy.width, enemy.height);
      }

      // Render the player.
      ctx.fillStyle = "#FF0000";
      ctx.fillRect(player.x - camX, player.y - camY, player.width, player.height);

      // UI overlay (Health and Inventory).
      ctx.fillStyle = "black";
      ctx.font = "16px sans-serif";
      ctx.fillText("Health: " + Math.floor(player.health), 10, 20);
      const invText = "Inventory: Dirt " + player.inventory.dirt +
                      ", Stone " + player.inventory.stone +
                      ", Grass " + player.inventory.grass +
                      ", Wood " + player.inventory.wood +
                      ", Leaves " + player.inventory.leaves;
      ctx.fillText(invText, 10, 40);

      // Day/Night overlay.
      let dayPhase = (timeCounter / dayCycle) * 2 * Math.PI;
      let brightness = (Math.cos(dayPhase) + 1) / 2;
      let darkAlpha = (1 - brightness) * 0.6;
      ctx.fillStyle = "rgba(0, 0, 0, " + darkAlpha + ")";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Game Over screen if health is depleted.
      if (player.health <= 0) {
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "48px sans-serif";
        ctx.fillText("Game Over", canvas.width / 2 - 100, canvas.height / 2);
      }
    }

    /***** Main Game Loop *****/
    function gameLoop() {
      if (player.health > 0) {
        updatePlayer();
        updateEnemies();
        updateTime();
      }
      render();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>
