<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Mario-Inspired Platformer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; margin: 0 auto; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="1200" height="800"></canvas>
<script>
  // ------------------------------
  // Global Constants and Variables
  // ------------------------------
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const CANVAS_WIDTH = canvas.width;
  const CANVAS_HEIGHT = canvas.height;
  const GRAVITY = 2500; // pixels per second²
  
  // gameState can be "menu", "play", or "win"
  let gameState = "menu";
  let currentLevelIndex = null;
  let currentLevel = null;
  let player = null;
  let enemies = []; // array for enemy objects
  let keys = {};
  
  // ------------------------------
  // Level Definitions
  // ------------------------------
  // Note: The levels here include a background color, platform layout, goal, and enemy spawn points.
  // Enemy spawn objects have an x, y coordinate (with y set so they land on their platform) and an initial vx.
  const levels = [
    {
      name: "Castle Courtyard",
      bgColor: "#87CEEB", // sky blue
      playerStart: { x: 100, y: 600 },
      platforms: [
        { x: 0,   y: 680, w: 1200, h: 120 }, // ground
        { x: 500, y: 550, w: 200,  h: 20 }
      ],
      goal: { x: 1080, y: 600, w: 80, h: 80 },
      enemySpawns: [
        { x: 600, y: 680 - 40, vx: 100 }  // enemy on the ground
      ]
    },
    {
      name: "Cool, Cool Mountain",
      bgColor: "#B0E0E6", // powder blue
      playerStart: { x: 50, y: 600 },
      platforms: [
        { x: 0,   y: 680, w: 1200, h: 120 },
        { x: 200, y: 550, w: 150,  h: 20 },
        { x: 400, y: 450, w: 150,  h: 20 },
        { x: 600, y: 350, w: 150,  h: 20 },
        { x: 800, y: 250, w: 150,  h: 20 }
      ],
      goal: { x: 950, y: 200, w: 50, h: 50 },
      enemySpawns: [
        { x: 250, y: 550 - 40, vx: 80 },   // on the first raised platform
        { x: 650, y: 350 - 40, vx: -80 }   // on the mid-level platform
      ]
    },
    {
      name: "Bowser's Fortress",
      bgColor: "#8B0000", // dark red
      playerStart: { x: 50, y: 600 },
      platforms: [
        { x: 0,   y: 680, w: 1200, h: 120 },
        { x: 200, y: 550, w: 200,  h: 20 },
        { x: 500, y: 500, w: 200,  h: 20 },
        { x: 800, y: 450, w: 200,  h: 20 }
      ],
      goal: { x: 1000, y: 400, w: 60, h: 60 },
      enemySpawns: [
        { x: 400, y: 680 - 40, vx: 120 }
      ]
    },
    {
      name: "Lethal Lava Land",
      bgColor: "#FFA500", // orange
      playerStart: { x: 50, y: 600 },
      platforms: [
        { x: 0,   y: 680, w: 1200, h: 120 },
        { x: 300, y: 600, w: 150,  h: 20 },
        { x: 600, y: 520, w: 200,  h: 20 },
        { x: 900, y: 440, w: 150,  h: 20 }
      ],
      goal: { x: 1050, y: 400, w: 50, h: 50 },
      enemySpawns: [
        { x: 350, y: 680 - 40, vx: 100 }
      ]
    },
    {
      name: "Tiny-Huge Island",
      bgColor: "#90EE90", // light green
      playerStart: { x: 50, y: 600 },
      platforms: [
        { x: 0,   y: 680, w: 1200, h: 120 },
        { x: 250, y: 600, w: 100,  h: 20 },
        { x: 400, y: 550, w: 200,  h: 20 },
        { x: 700, y: 500, w: 120,  h: 20 },
        { x: 900, y: 450, w: 150,  h: 20 }
      ],
      goal: { x: 1050, y: 400, w: 50, h: 50 },
      enemySpawns: [
        { x: 800, y: 500 - 40, vx: 90 }
      ]
    },
    {
      name: "Tick-Tock Clock",
      bgColor: "#708090", // slate gray
      playerStart: { x: 50, y: 600 },
      platforms: [
        { x: 0,   y: 680, w: 1200, h: 120 },
        { x: 150, y: 550, w: 100,  h: 20 },
        { x: 300, y: 500, w: 100,  h: 20 },
        { x: 450, y: 450, w: 100,  h: 20 },
        { x: 600, y: 400, w: 100,  h: 20 },
        { x: 750, y: 350, w: 100,  h: 20 },
        { x: 900, y: 300, w: 100,  h: 20 }
      ],
      goal: { x: 1050, y: 250, w: 50, h: 50 },
      enemySpawns: [
        { x: 500, y: 500 - 40, vx: -100 }
      ]
    }
  ];
  
  // ------------------------------
  // Helper Functions
  // ------------------------------
  
  // Returns whether two rectangles (r1 and r2) intersect.
  function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w ||
             r2.x + r2.w < r1.x ||
             r2.y > r1.y + r1.h ||
             r2.y + r2.h < r1.y);
  }
  
  // ------------------------------
  // Drawing Functions
  // ------------------------------
  
  // Draws the player with a Mario‑like appearance.
  function drawPlayer(ctx, p) {
    ctx.save();
    ctx.translate(p.x, p.y);
    // Draw a red, curved cap.
    const capRadius = p.width * 0.6;
    ctx.fillStyle = "#FF0000"; // red cap
    ctx.beginPath();
    ctx.arc(p.width/2, -capRadius/2, capRadius, Math.PI, 2*Math.PI);
    ctx.fill();
    // Draw the head (circle) with a skin tone.
    ctx.fillStyle = "#FDB99B"; 
    ctx.beginPath();
    ctx.arc(p.width/2, 0, p.width/2, 0, 2 * Math.PI);
    ctx.fill();
    // Draw overalls as a blue rectangle on the lower half.
    ctx.fillStyle = "#0000FF";
    ctx.fillRect(0, p.height/2, p.width, p.height/2);
    ctx.restore();
  }
  
  // Draws an enemy resembling a classic Goomba.
  function drawEnemy(ctx, enemy) {
    ctx.save();
    ctx.translate(enemy.x, enemy.y);
    // Draw a brown body.
    ctx.fillStyle = "#8B4513";
    ctx.fillRect(0, 0, enemy.width, enemy.height);
    // Draw two white eyes.
    ctx.fillStyle = "#FFF";
    ctx.beginPath();
    ctx.arc(enemy.width * 0.3, enemy.height * 0.3, enemy.width * 0.1, 0, 2 * Math.PI);
    ctx.arc(enemy.width * 0.7, enemy.height * 0.3, enemy.width * 0.1, 0, 2 * Math.PI);
    ctx.fill();
    // Draw pupils.
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(enemy.width * 0.3, enemy.height * 0.3, enemy.width * 0.05, 0, 2 * Math.PI);
    ctx.arc(enemy.width * 0.7, enemy.height * 0.3, enemy.width * 0.05, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();
  }
  
  // Draw platforms, the goal, and (later) the enemies.
  function drawPlay() {
    // Set the background color defined for the current level.
    ctx.fillStyle = currentLevel.bgColor;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  
    // Draw each platform.
    for (let plat of currentLevel.platforms) {
      ctx.fillStyle = "#444";
      ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
    }
  
    // Draw the goal block.
    const goal = currentLevel.goal;
    ctx.fillStyle = "#FFD700";
    ctx.fillRect(goal.x, goal.y, goal.w, goal.h);
  
    // Draw the player.
    drawPlayer(ctx, player);
  
    // Draw each enemy.
    for (let enemy of enemies) {
      drawEnemy(ctx, enemy);
    }
  
    // Draw level name in the top-left.
    ctx.fillStyle = "#000";
    ctx.font = "24px Arial";
    ctx.fillText(currentLevel.name, 20, 40);
  }
  
  // Draw the menu screen.
  function drawMenu() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    ctx.fillStyle = "#FFF";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Mario-Inspired Platformer", CANVAS_WIDTH / 2, 100);
    ctx.font = "30px Arial";
    const startY = 200;
    const spacing = 50;
    for (let i = 0; i < levels.length; i++) {
      const itemY = startY + i * spacing;
      ctx.fillStyle = "#FFD700";
      ctx.fillText((i+1) + ". " + levels[i].name, CANVAS_WIDTH / 2, itemY);
    }
    ctx.font = "20px Arial";
    ctx.fillStyle = "#FFF";
    ctx.fillText("Click on a level to play", CANVAS_WIDTH / 2, startY + levels.length * spacing + 40);
  }
  
  // Draw win screen.
  function drawWin() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    ctx.fillStyle = "#0F0";
    ctx.font = "50px Arial";
    ctx.textAlign = "center";
    ctx.fillText("You Reached The Goal!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
    ctx.font = "30px Arial";
    ctx.fillText("Click to return to the menu", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
  }
  
  // ------------------------------
  // Input and Level Setup
  // ------------------------------
  
  // Set up keyboard input.
  window.addEventListener("keydown", function (e) {
    keys[e.code] = true;
  });
  window.addEventListener("keyup", function (e) {
    keys[e.code] = false;
  });
  
  // On canvas click, use different behaviors depending on the game state.
  canvas.addEventListener("click", function(e) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
  
    if (gameState === "menu") {
      // In the menu, click within a region corresponding to a level.
      const startY = 200;
      const spacing = 50;
      for (let i = 0; i < levels.length; i++) {
        const itemY = startY + i * spacing;
        if (mouseY >= itemY - 30 && mouseY <= itemY) {
          startLevel(i);
          break;
        }
      }
    } else if (gameState === "win") {
      goToMenu();
    }
  });
  
  // Initialize and start a level.
  function startLevel(index) {
    currentLevelIndex = index;
    currentLevel = levels[index];
    // Create the player.
    player = {
      x: currentLevel.playerStart.x,
      y: currentLevel.playerStart.y,
      prevY: currentLevel.playerStart.y,
      width: 50,
      height: 50,
      vx: 0,
      vy: 0,
      speed: 300,      // horizontal speed
      jumpPower: -800, // negative for upward jump
      onGround: false
    };
    // Create enemies from enemySpawns.
    enemies = [];
    if (currentLevel.enemySpawns) {
      for (const spawn of currentLevel.enemySpawns) {
        enemies.push({
          x: spawn.x,
          y: spawn.y,
          width: 40,
          height: 40,
          vx: spawn.vx,
          vy: 0,
          onGround: false
        });
      }
    }
    gameState = "play";
  }
  
  function goToMenu() {
    gameState = "menu";
    currentLevel = null;
    currentLevelIndex = null;
    player = null;
    enemies = [];
  }
  
  // ------------------------------
  // Physics and Update Functions
  // ------------------------------
  
  // Update the player with basic physics and collisions.
  function updatePlayer(dt) {
    if (!player) return;
    player.prevY = player.y;
  
    // Horizontal movement.
    if (keys["ArrowLeft"]) {
      player.vx = -player.speed;
    } else if (keys["ArrowRight"]) {
      player.vx = player.speed;
    } else {
      player.vx = 0;
    }
    // Jump if on the ground.
    if ((keys["ArrowUp"] || keys["Space"]) && player.onGround) {
      player.vy = player.jumpPower;
      player.onGround = false;
    }
    // Update position and apply gravity.
    player.x += player.vx * dt;
    player.y += player.vy * dt;
    player.vy += GRAVITY * dt;
  
    // Simple collision against all platforms.
    player.onGround = false;
    for (const plat of currentLevel.platforms) {
      let pRect = { x: plat.x, y: plat.y, w: plat.w, h: plat.h };
      let playerRect = { x: player.x, y: player.y, w: player.width, h: player.height };
      if (rectIntersect(playerRect, pRect)) {
        // Only resolve if falling onto the platform.
        if (player.vy >= 0 && (player.prevY + player.height) <= plat.y + 5) {
          player.y = plat.y - player.height;
          player.vy = 0;
          player.onGround = true;
        }
      }
    }
  
    // Restart the level if the player falls off.
    if (player.y > CANVAS_HEIGHT) {
      startLevel(currentLevelIndex);
    }
  }
  
  // Update enemies: apply gravity, basic platform collision, and turn them upon reaching platform edges.
  function updateEnemies(dt) {
    for (let i = enemies.length - 1; i >= 0; i--) {
      let enemy = enemies[i];
      enemy.x += enemy.vx * dt;
      enemy.y += enemy.vy * dt;
      enemy.vy += GRAVITY * dt;
  
      enemy.onGround = false;
      // Check for collisions with platforms.
      for (const plat of currentLevel.platforms) {
        let platRect = { x: plat.x, y: plat.y, w: plat.w, h: plat.h };
        let enemyRect = { x: enemy.x, y: enemy.y, w: enemy.width, h: enemy.height };
        if (rectIntersect(enemyRect, platRect)) {
          if (enemy.vy >= 0 && (enemy.y - enemy.vy * dt + enemy.height) <= plat.y + 5) {
            enemy.y = plat.y - enemy.height;
            enemy.vy = 0;
            enemy.onGround = true;
            // Simple edge detection: if at the edge of the platform, reverse direction.
            if (enemy.x <= plat.x + 5 || enemy.x + enemy.width >= plat.x + plat.w - 5) {
              enemy.vx = -enemy.vx;
            }
          }
        }
      }
  
      // Remove enemy if it falls below the canvas.
      if (enemy.y > CANVAS_HEIGHT) {
        enemies.splice(i, 1);
      }
    }
  }
  
  // Check for collisions between the player and enemies.
  function checkPlayerEnemyCollisions() {
    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      const playerRect = { x: player.x, y: player.y, w: player.width, h: player.height };
      const enemyRect = { x: enemy.x, y: enemy.y, w: enemy.width, h: enemy.height };
      if (rectIntersect(playerRect, enemyRect)) {
        // If the player is falling and the previous bottom was above the enemy's top, the enemy is stomped.
        if (player.vy > 0 && (player.prevY + player.height) <= enemy.y + 10) {
          enemies.splice(i, 1);
          player.vy = player.jumpPower / 2; // bounce effect
        } else {
          // Otherwise, restart the level.
          startLevel(currentLevelIndex);
        }
      }
    }
  }
  
  // Check if the player reaches the goal.
  function checkGoal() {
    const goal = currentLevel.goal;
    const playerRect = { x: player.x, y: player.y, w: player.width, h: player.height };
    if (rectIntersect(playerRect, goal)) {
      gameState = "win";
    }
  }
  
  function update(dt) {
    if (gameState !== "play") return;
    updatePlayer(dt);
    updateEnemies(dt);
    checkPlayerEnemyCollisions();
    checkGoal();
  }
  
  // ------------------------------
  // Game Loop and Drawing
  // ------------------------------
  let lastTime = performance.now();
  function gameLoop(currentTime) {
    let dt = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
  
    if (gameState === "play") {
      update(dt);
    }
  
    // Draw based on game state.
    if (gameState === "menu") {
      drawMenu();
    } else if (gameState === "play") {
      drawPlay();
    } else if (gameState === "win") {
      drawWin();
    }
  
    requestAnimationFrame(gameLoop);
  }
  
  // Start in the menu.
  function init() {
    goToMenu();
    requestAnimationFrame(gameLoop);
  }
  
  init();
</script>
</body>
</html>
