<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Minecraft-like Demo (No Libraries)</title>
  <style>
    /* Remove default margins and ensure the canvas fills the screen */
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; background-color: #000; }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>
  <script>
    // Get the canvas and initialize WebGL.
    const canvas = document.getElementById("glCanvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const gl = canvas.getContext("webgl");
    if (!gl) {
      alert("WebGL not supported in this browser.");
    }

    // --- Shader sources ---
    const vsSource = `
      attribute vec3 aPosition;
      attribute vec3 aColor;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      varying vec3 vColor;
      void main(void) {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
        vColor = aColor;
      }
    `;

    const fsSource = `
      precision mediump float;
      varying vec3 vColor;
      void main(void) {
        gl_FragColor = vec4(vColor, 1.0);
      }
    `;

    // --- Shader Compilation Helpers ---
    function loadShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function initShaderProgram(vsSource, fsSource) {
      const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
        return null;
      }
      return shaderProgram;
    }

    const shaderProgram = initShaderProgram(vsSource, fsSource);
    gl.useProgram(shaderProgram);

    // --- Look Up Attribute/Uniform Locations ---
    const programInfo = {
      attribLocations: {
        vertexPosition: gl.getAttribLocation(shaderProgram, 'aPosition'),
        vertexColor: gl.getAttribLocation(shaderProgram, 'aColor'),
      },
      uniformLocations: {
        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
      },
    };

    // --- Cube Geometry Data ---
    const positions = [
      // Front Face
      -1.0, -1.0,  1.0,
       1.0, -1.0,  1.0,
       1.0,  1.0,  1.0,
      -1.0,  1.0,  1.0,
      // Back Face
      -1.0, -1.0, -1.0,
      -1.0,  1.0, -1.0,
       1.0,  1.0, -1.0,
       1.0, -1.0, -1.0,
      // Top Face
      -1.0,  1.0, -1.0,
      -1.0,  1.0,  1.0,
       1.0,  1.0,  1.0,
       1.0,  1.0, -1.0,
      // Bottom Face
      -1.0, -1.0, -1.0,
       1.0, -1.0, -1.0,
       1.0, -1.0,  1.0,
      -1.0, -1.0,  1.0,
      // Right Face
       1.0, -1.0, -1.0,
       1.0,  1.0, -1.0,
       1.0,  1.0,  1.0,
       1.0, -1.0,  1.0,
      // Left Face
      -1.0, -1.0, -1.0,
      -1.0, -1.0,  1.0,
      -1.0,  1.0,  1.0,
      -1.0,  1.0, -1.0,
    ];

    const faceColors = [
      [1.0,  0.0,  0.0], // Front: red
      [0.0,  1.0,  0.0], // Back: green
      [0.0,  0.0,  1.0], // Top: blue
      [1.0,  1.0,  0.0], // Bottom: yellow
      [1.0,  0.0,  1.0], // Right: magenta
      [0.0,  1.0,  1.0], // Left: cyan
    ];

    let colors = [];
    for (let i = 0; i < faceColors.length; i++) {
      const c = faceColors[i];
      for (let j = 0; j < 4; j++) {
        colors = colors.concat(c);
      }
    }

    const indices = [
      0, 1, 2,    0, 2, 3,      // Front face
      4, 5, 6,    4, 6, 7,      // Back face
      8, 9, 10,   8, 10, 11,    // Top face
      12, 13, 14, 12, 14, 15,    // Bottom face
      16, 17, 18, 16, 18, 19,    // Right face
      20, 21, 22, 20, 22, 23     // Left face
    ];

    // --- Create and Bind Buffers ---
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(
      programInfo.attribLocations.vertexPosition,
      3, gl.FLOAT, false, 0, 0
    );
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.vertexAttribPointer(
      programInfo.attribLocations.vertexColor,
      3, gl.FLOAT, false, 0, 0
    );
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);

    // --- Minimal Matrix Utility Functions ---
    function identity() {
      return [
         1, 0, 0, 0,
         0, 1, 0, 0,
         0, 0, 1, 0,
         0, 0, 0, 1
      ];
    }

    function perspective(fov, aspect, near, far) {
      const f = 1.0 / Math.tan(fov / 2);
      const rangeInv = 1 / (near - far);
      return [
        f / aspect, 0, 0,                             0,
        0,          f, 0,                             0,
        0,          0, (near + far) * rangeInv,        -1,
        0,          0, near * far * rangeInv * 2,       0
      ];
    }

    function multiply(a, b) {
      const out = new Array(16);
      for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
          out[i * 4 + j] =
            a[i * 4 + 0] * b[0 * 4 + j] +
            a[i * 4 + 1] * b[1 * 4 + j] +
            a[i * 4 + 2] * b[2 * 4 + j] +
            a[i * 4 + 3] * b[3 * 4 + j];
        }
      }
      return out;
    }

    function rotateY(m, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const rotation = [
         c, 0, s, 0,
         0, 1, 0, 0,
        -s, 0, c, 0,
         0, 0, 0, 1
      ];
      return multiply(m, rotation);
    }

    function rotateX(m, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const rotation = [
        1,  0, 0, 0,
        0,  c, s, 0,
        0, -s, c, 0,
        0,  0, 0, 1
      ];
      return multiply(m, rotation);
    }

    function translate(m, tx, ty, tz) {
      const translation = [
         1, 0, 0, 0,
         0, 1, 0, 0,
         0, 0, 1, 0,
         tx, ty, tz, 1
      ];
      return multiply(m, translation);
    }

    // --- Animation Loop ---
    let previousTime = 0;
    let angle = 0;
    function render(currentTime) {
      currentTime *= 0.001;
      const deltaTime = currentTime - previousTime;
      previousTime = currentTime;
      angle += deltaTime;

      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearDepth(1.0);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);

      // Create projection matrix.
      const fieldOfView = 60 * Math.PI / 180;
      const aspect = canvas.clientWidth / canvas.clientHeight;
      const projectionMatrix = perspective(fieldOfView, aspect, 0.1, 100.0);

      // Build model-view matrix.
      let modelViewMatrix = identity();
      modelViewMatrix = translate(modelViewMatrix, 0, 0, -6);
      modelViewMatrix = rotateY(modelViewMatrix, angle);
      modelViewMatrix = rotateX(modelViewMatrix, angle * 0.7);

      // IMPORTANT: Because our matrices are in row-major order,
      // we pass true as the transpose parameter so WebGL interprets
      // them correctly as column-major.
      gl.uniformMatrix4fv(
        programInfo.uniformLocations.projectionMatrix,
        true, new Float32Array(projectionMatrix)
      );
      gl.uniformMatrix4fv(
        programInfo.uniformLocations.modelViewMatrix,
        true, new Float32Array(modelViewMatrix)
      );

      // Draw the cube.
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>
</html>
