<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Mario 64 – Fully (Simplified) in HTML</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
    <!-- Include Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  </head>
  <body>
    <script>
      /*********************************************
       * Setup Three.js Scene, Camera, and Renderer
       *********************************************/
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // Sky blue background
      
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add some lights
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(100, 100, 50);
      scene.add(directionalLight);
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      /*********************************************
       * Level Geometry: Ground and Platforms
       *********************************************/
      // Create a grassy ground (a large green box)
      const groundGeometry = new THREE.BoxGeometry(200, 2, 200);
      const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.position.set(0, -1, 0);
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Array to hold platform meshes for collision detection.
      const platforms = [];
      
      // Helper: create a platform at a given position.
      function createPlatform(x, y, z, width, depth, height, color) {
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshPhongMaterial({ color: color });
        const platform = new THREE.Mesh(geometry, material);
        platform.position.set(x, y, z);
        platform.castShadow = true;
        platform.receiveShadow = true;
        scene.add(platform);
        platforms.push(platform);
      }
      
      // Create some platforms to simulate level geometry.
      createPlatform(0, 5, -30, 20, 20, 2, 0x808080);
      createPlatform(30, 10, -60, 15, 15, 2, 0x808080);
      createPlatform(-25, 15, -90, 20, 20, 2, 0x808080);
      createPlatform(40, 20, -120, 25, 25, 2, 0x808080);
      
      /*********************************************
       * Player Setup – A Mario‑like Character
       *********************************************/
      // We construct the player as a THREE.Group.
      const player = new THREE.Group();
      
      // Torso: red box (represents Mario’s shirt)
      const torsoGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
      const torsoMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
      torso.position.y = 0.75; // raise so torso sits above the “legs”
      player.add(torso);
      
      // Legs (blue overalls) – two small boxes
      const legGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.4);
      const legMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff });
      const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.3, -0.3, 0);
      const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.3, -0.3, 0);
      player.add(leftLeg);
      player.add(rightLeg);
      
      // Head: a sphere (skin-toned)
      const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const headMaterial = new THREE.MeshPhongMaterial({ color: 0xfdb99b });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.5;
      player.add(head);
      
      // Cap: a red half‑sphere (using a partial sphere geometry)
      const capGeometry = new THREE.SphereGeometry(0.55, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      const capMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      const cap = new THREE.Mesh(capGeometry, capMaterial);
      cap.position.y = 1.7;
      player.add(cap);
      
      // Set the player's initial position.
      player.position.set(0, 0, 0);
      scene.add(player);
      
      // Player physics variables.
      const playerVelocity = new THREE.Vector3(0, 0, 0);
      const PLAYER_SPEED = 10;    // horizontal speed
      const JUMP_VELOCITY = 15;   // initial jump velocity
      let playerOnGround = false;
      
      /*********************************************
       * Enemy Setup – A Simple Roaming Foe
       *********************************************/
      // Create an enemy as a brown cube.
      const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
      const enemyMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      enemy.position.set(5, 0, -20);
      scene.add(enemy);
      
      let enemyDirection = 1; // moves along +X then reverses.
      const ENEMY_SPEED = 2;
      
      /*********************************************
       * Input Handling
       *********************************************/
      const keysPressed = {};
      document.addEventListener('keydown', (e) => {
        keysPressed[e.code] = true;
      });
      document.addEventListener('keyup', (e) => {
        keysPressed[e.code] = false;
      });
      
      /*********************************************
       * Camera Configuration – Third-Person Follow
       *********************************************/
      // Set an initial camera position.
      camera.position.set(0, 5, 10);
      camera.lookAt(player.position);
      
      /*********************************************
       * Simple Collision Detection Utility
       *********************************************/
      // Uses Three.js Box3 to compute axis-aligned bounding boxes.
      function checkCollision(object1, object2) {
        const box1 = new THREE.Box3().setFromObject(object1);
        const box2 = new THREE.Box3().setFromObject(object2);
        return box1.intersectsBox(box2);
      }
      
      /*********************************************
       * Game Loop and Physics Update
       *********************************************/
      const GRAVITY = 30; // gravity acceleration constant
      
      const clock = new THREE.Clock();
      function animate() {
        const dt = clock.getDelta(); // seconds elapsed since last frame
        
        // --- Handle Player Input & Movement ---
        let moveDirection = new THREE.Vector3(0, 0, 0);
        if (keysPressed['KeyW']) moveDirection.z -= 1;
        if (keysPressed['KeyS']) moveDirection.z += 1;
        if (keysPressed['KeyA']) moveDirection.x -= 1;
        if (keysPressed['KeyD']) moveDirection.x += 1;
        moveDirection.normalize(); // in case of diagonal movement
        
        // Update horizontal components of velocity.
        playerVelocity.x = moveDirection.x * PLAYER_SPEED;
        playerVelocity.z = moveDirection.z * PLAYER_SPEED;
        
        // Jumping: if space is pressed and the player is on the ground.
        if (keysPressed['Space'] && playerOnGround) {
          playerVelocity.y = JUMP_VELOCITY;
          playerOnGround = false;
        }
        
        // Apply gravity.
        playerVelocity.y -= GRAVITY * dt;
        
        // Update player position.
        player.position.addScaledVector(playerVelocity, dt);
        
        // --- Collision with the Ground ---
        if (player.position.y < 0) {
          player.position.y = 0;
          playerVelocity.y = 0;
          playerOnGround = true;
        }
        
        // --- Collision with Platforms ---
        platforms.forEach(function (plat) {
          // Compute bounding boxes.
          const playerBox = new THREE.Box3().setFromObject(player);
          const platBox = new THREE.Box3().setFromObject(plat);
          // If colliding, and if the player is falling onto the platform, adjust position.
          if (playerBox.intersectsBox(platBox)) {
            // Simple resolution: assume collision from above.
            if (player.position.y > plat.position.y) {
              player.position.y = plat.position.y + (plat.geometry.parameters.height / 2) + 1;
              playerVelocity.y = 0;
              playerOnGround = true;
            }
          }
        });
        
        // --- Enemy Movement (Simple Patrol) ---
        enemy.position.x += ENEMY_SPEED * enemyDirection * dt;
        if (enemy.position.x > 10) {
          enemyDirection = -1;
        } else if (enemy.position.x < 0) {
          enemyDirection = 1;
        }
        
        // --- Check Collision with Enemy ---
        if (checkCollision(player, enemy)) {
          // If collision, reset player to the level start.
          player.position.set(0, 0, 0);
          playerVelocity.set(0, 0, 0);
        }
        
        // --- Update Camera to Follow Player ---
        // Smoothly move the camera toward a position behind and above the player.
        const desiredCameraPos = new THREE.Vector3(
          player.position.x,
          player.position.y + 5,
          player.position.z + 10
        );
        camera.position.lerp(desiredCameraPos, 0.1);
        camera.lookAt(player.position);
        
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
      
      /*********************************************
       * Handle Window Resize
       *********************************************/
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
