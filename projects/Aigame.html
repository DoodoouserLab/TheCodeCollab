<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini Terraria Clone</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #87CEEB; /* Sky blue */
    }
    canvas {
      display: block;
      background: #87CEEB;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    // Setup canvas and context
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Adjust canvas size to full window
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Define world configuration
    const tileSize = 16; // size of each block in pixels
    const worldWidth = 200; // number of horizontal blocks in the world
    const worldHeight = 100; // number of vertical blocks

    // World tile legend:
    // 0 = air, 1 = dirt, 2 = stone, 3 = grass
    const world = [];

    // Generate a basic 2D world:
    // We'll use a mix of sine waves and random variation to create simple terrain.
    for (let x = 0; x < worldWidth; x++) {
      world[x] = [];
      // Calculate a pseudo-ground level for current x. 
      let groundHeight = Math.floor(30 + 10 * Math.sin(x * 0.2) + Math.random() * 3);
      for (let y = 0; y < worldHeight; y++) {
        if (y > groundHeight) { 
          // For blocks under the ground surface, mix stone and dirt.
          if (y === groundHeight + 1) {
            world[x][y] = 1; // dirt layer right below the surface
          } else {
            world[x][y] = (Math.random() < 0.2) ? 1 : 2; // Occasionally mix dirt with stone
          }
        } else if (y === groundHeight) {
          world[x][y] = 3; // surface grass block
        } else {
          world[x][y] = 0; // air above ground
        }
      }
    }

    // Player object
    const player = {
      x: 50, // in world coordinates
      y: 20,
      width: tileSize,
      height: tileSize * 1.8, // roughly two blocks high
      vx: 0,
      vy: 0,
      speed: 2,
      grounded: false
    };

    // Keyboard input handling
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true; });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    // Utility functions to check and manipulate blocks
    function isSolid(block) {
      return block > 0; // all non-air blocks are solid
    }

    function getBlock(x, y) {
      if (x < 0 || x >= worldWidth || y < 0 || y >= worldHeight) return 0;
      return world[x][y];
    }

    function setBlock(x, y, block) {
      if (x < 0 || x >= worldWidth || y < 0 || y >= worldHeight) return;
      world[x][y] = block;
    }

    // Update player physics and handle collisions
    function updatePlayer() {
      // Handle horizontal movement
      if (keys['a'] || keys['ArrowLeft']) {
        player.vx = -player.speed;
      } else if (keys['d'] || keys['ArrowRight']) {
        player.vx = player.speed;
      } else {
        player.vx = 0;
      }

      // Jump if on ground
      if ((keys['w'] || keys['ArrowUp'] || keys[' ']) && player.grounded) {
        player.vy = -8;
        player.grounded = false;
      }

      // Apply gravity
      player.vy += 0.4;

      // --- Horizontal Movement Collision ---
      player.x += player.vx;
      let leftTile = Math.floor(player.x / tileSize);
      let rightTile = Math.floor((player.x + player.width) / tileSize);
      let topTile = Math.floor(player.y / tileSize);
      let bottomTile = Math.floor((player.y + player.height) / tileSize);
      for (let x = leftTile; x <= rightTile; x++) {
        for (let y = topTile; y <= bottomTile; y++) {
          if (isSolid(getBlock(x, y))) {
            if (player.vx > 0) {
              player.x = x * tileSize - player.width;
            } else if (player.vx < 0) {
              player.x = (x + 1) * tileSize;
            }
            player.vx = 0;
          }
        }
      }

      // --- Vertical Movement Collision ---
      player.y += player.vy;
      player.grounded = false;
      leftTile = Math.floor(player.x / tileSize);
      rightTile = Math.floor((player.x + player.width) / tileSize);
      topTile = Math.floor(player.y / tileSize);
      bottomTile = Math.floor((player.y + player.height) / tileSize);
      for (let x = leftTile; x <= rightTile; x++) {
        for (let y = topTile; y <= bottomTile; y++) {
          if (isSolid(getBlock(x, y))) {
            if (player.vy > 0) {
              player.y = y * tileSize - player.height;
              player.grounded = true;
            } else if (player.vy < 0) {
              player.y = (y + 1) * tileSize;
            }
            player.vy = 0;
          }
        }
      }
    }

    // Mining mechanic: on mouse click, remove a block if it is close enough.
    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Camera offset in world coordinates
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      let blockX = Math.floor((mouseX + camX) / tileSize);
      let blockY = Math.floor((mouseY + camY) / tileSize);

      // Check distance between player and block (roughly within 5 tiles)
      const playerTileX = Math.floor(player.x / tileSize);
      const playerTileY = Math.floor(player.y / tileSize);
      const dx = blockX - playerTileX;
      const dy = blockY - playerTileY;
      if (dx * dx + dy * dy <= 25 && isSolid(getBlock(blockX, blockY))) {
        setBlock(blockX, blockY, 0); // "mine" by removing the block
      }
    });

    // Render the world and the player
    function render() {
      // Clear the screen
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Simple camera: center on the player
      let camX = player.x - canvas.width / 2;
      let camY = player.y - canvas.height / 2;
      // Clamp camera to world bounds
      camX = Math.max(0, Math.min(camX, worldWidth * tileSize - canvas.width));
      camY = Math.max(0, Math.min(camY, worldHeight * tileSize - canvas.height));

      // Render world tiles
      for (let x = 0; x < worldWidth; x++) {
        for (let y = 0; y < worldHeight; y++) {
          const block = getBlock(x, y);
          if (block !== 0) {
            let color = "#000";
            if (block === 1) color = "#8B4513";   // Dirt
            if (block === 2) color = "#808080";     // Stone
            if (block === 3) color = "#228B22";     // Grass
            ctx.fillStyle = color;
            ctx.fillRect(x * tileSize - camX, y * tileSize - camY, tileSize, tileSize);
          }
        }
      }

      // Render player as a red rectangle
      ctx.fillStyle = "#FF0000";
      ctx.fillRect(player.x - camX, player.y - camY, player.width, player.height);
    }

    // Main game loop
    function gameLoop() {
      updatePlayer();
      render();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
