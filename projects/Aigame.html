<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Minecraft-like World with Villages, Biomes & Mountains</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
      /* Overlay for pointer lock instructions */
      #blocker {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }
      #instructions {
        color: white;
        font-family: Arial, sans-serif;
        font-size: 36px;
        cursor: pointer;
      }
      /* Centered crosshair */
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        margin-left: -10px;
        margin-top: -10px;
        z-index: 1;
        pointer-events: none;
        text-align: center;
        font-weight: bold;
        color: red;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">Click to Play</div>
    </div>
    <div id="crosshair">+</div>
    
    <!-- Three.js, PointerLockControls, and ImprovedNoise -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/PointerLockControls.js"></script>
    <script src="https://threejs.org/examples/js/objects/ImprovedNoise.js"></script>
    
    <script>
      // SCENE SETUP
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // Sky-blue
      
      const camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );
      camera.position.set(0, 15, 25);
      
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // FIRST-PERSON CONTROLS (PointerLockControls)
      const controls = new THREE.PointerLockControls(camera, document.body);
      scene.add(controls.getObject());
      
      const blocker = document.getElementById("blocker");
      const instructions = document.getElementById("instructions");
      instructions.addEventListener("click", () => {
        controls.lock();
      }, false);
      controls.addEventListener("lock", () => {
        blocker.style.display = "none";
      });
      controls.addEventListener("unlock", () => {
        blocker.style.display = "flex";
      });
      
      // MOVEMENT VARIABLES
      let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      let prevTime = performance.now();
      
      document.addEventListener("keydown", (event) => {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
            moveForward = true; break;
          case "ArrowLeft":
          case "KeyA":
            moveLeft = true; break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true; break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true; break;
          case "Space":
            if (canJump) velocity.y += 10;
            canJump = false; break;
        }
      }, false);
      
      document.addEventListener("keyup", (event) => {
        switch(event.code) {
          case "ArrowUp":
          case "KeyW": moveForward = false; break;
          case "ArrowLeft":
          case "KeyA": moveLeft = false; break;
          case "ArrowDown":
          case "KeyS": moveBackward = false; break;
          case "ArrowRight":
          case "KeyD": moveRight = false; break;
        }
      }, false);
      
      // LIGHTING
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 200, 100);
      scene.add(directionalLight);
      
      // TEXTURES & MATERIALS
      const textureLoader = new THREE.TextureLoader();
      const grassTexture = textureLoader.load("https://i.imgur.com/1c6Z1qv.png");
      grassTexture.magFilter = THREE.NearestFilter;
      grassTexture.minFilter = THREE.NearestFilter;
      
      const grassMaterial = new THREE.MeshLambertMaterial({ map: grassTexture });
      const dirtMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
      const sandMaterial = new THREE.MeshLambertMaterial({ color: 0xE4D96F });
      const sandstoneMaterial = new THREE.MeshLambertMaterial({ color: 0xC2B280 });
      const snowMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      
      // Materials used for village houses
      const woodMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const woodMaterialFloor = new THREE.MeshLambertMaterial({ color: 0xCD853F });
      const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xA52A2A });
      
      // Global array for interactive blocks (used for raycasting)
      const objects = [];
      
      // Helper: create a block at (x, y, z) with chosen material
      function createBlock(x, y, z, material) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y, z);
        scene.add(cube);
        objects.push(cube);
        return cube;
      }
      
      // NOISE & TERRAIN PARAMETERS
      const noise = new ImprovedNoise();
      const seed = Math.random() * 100;
      const noiseScale = 10;
      const amplitude = 4;
      
      // This function calculates the terrain height and assigns a biome type
      // based on a secondary noise function.
      function calculateTerrainHeight(worldX, worldZ) {
        let noiseValue = noise.noise(worldX / noiseScale, seed, worldZ / noiseScale);
        let biomeValue = noise.noise(worldX / 15, seed + 100, worldZ / 15);
        let biomeType, baseHeight;
        if (biomeValue < -0.3) {
          biomeType = 'desert';
          baseHeight = Math.floor((noiseValue + 1) * (amplitude / 3));
        } else if (biomeValue > 0.5) {
          biomeType = 'mountain';
          baseHeight = Math.floor((noiseValue + 1) * (amplitude * 1.5));
        } else {
          biomeType = 'grassland';
          baseHeight = Math.floor((noiseValue + 1) * (amplitude / 2));
        }
        return { height: baseHeight, biome: biomeType };
      }
      
      // MAIN TERRAIN GENERATION
      const worldWidth = 64;
      const worldDepth = 64;
      for (let i = -worldWidth / 2; i < worldWidth / 2; i++) {
        for (let j = -worldDepth / 2; j < worldDepth / 2; j++) {
          const { height: h, biome: biomeType } = calculateTerrainHeight(i, j);
          for (let y = 0; y <= h; y++) {
            let mat;
            if (biomeType === 'desert') {
              mat = (y === h) ? sandMaterial : sandstoneMaterial;
            } else {
              if (biomeType === 'mountain' && h >= 8 && y === h) {
                mat = snowMaterial;
              } else if (y === h && (biomeType === 'grassland' || biomeType === 'mountain')) {
                mat = grassMaterial;
              } else if (y >= h - 2) {
                mat = dirtMaterial;
              } else {
                mat = stoneMaterial;
              }
            }
            createBlock(i, y, j, mat);
          }
        }
      }
      
      // Add a large ground plane beneath for safety
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshLambertMaterial({ color: 0x55aa55 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1;
      scene.add(ground);
      
      // VILLAGE GENERATION
      
      // This function builds a simple house using a 5×5 footprint with walls, a door gap, and a flat roof.
      function createHouse(baseX, baseZ) {
        // Determine the ground level at the house location.
        const { height: groundHeight } = calculateTerrainHeight(baseX, baseZ);
        const baseY = groundHeight + 1;
        // Floor for the house
        for (let x = 0; x < 5; x++) {
          for (let z = 0; z < 5; z++) {
            createBlock(baseX + x, baseY - 1, baseZ + z, woodMaterialFloor);
          }
        }
        // Walls: build a hollow cube of wood with a gap for the door
        for (let x = 0; x < 5; x++) {
          for (let y = 0; y < 4; y++) {
            for (let z = 0; z < 5; z++) {
              // Leave a door gap at the center of the front wall (z === 0, x === 2)
              if (z === 0 && x === 2 && (y === 0 || y === 1)) continue;
              if (x === 0 || x === 4 || z === 0 || z === 4) {
                createBlock(baseX + x, baseY + y, baseZ + z, woodMaterial);
              }
            }
          }
        }
        // A flat roof with a slight overhang
        for (let x = -1; x < 6; x++) {
          for (let z = -1; z < 6; z++) {
            createBlock(baseX + x, baseY + 4, baseZ + z, roofMaterial);
          }
        }
      }
      
      // This function spawns a cluster of houses in a grid formation.
      function generateVillage(centerX, centerZ) {
        const gridSize = 5; // 5×5 grid of houses
        const spacing = 10;  // Space between houses
        for (let i = -Math.floor(gridSize / 2); i <= Math.floor(gridSize / 2); i++) {
          for (let j = -Math.floor(gridSize / 2); j <= Math.floor(gridSize / 2); j++) {
            // Random chance to leave gaps between houses
            if (Math.random() < 0.7) {
              createHouse(centerX + i * spacing, centerZ + j * spacing);
            }
          }
        }
      }
      
      // Spawn one village (you can call generateVillage more times at different spots)
      generateVillage(0, 0);
      
      // RAYCASTER for interactive "digging" (block removal with left-click)
      const raycaster = new THREE.Raycaster();
      document.addEventListener("mousedown", (event) => {
        if (!controls.isLocked) return;
        if (event.button === 0) {
          raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
          const intersects = raycaster.intersectObjects(objects);
          if (intersects.length > 0) {
            const selected = intersects[0].object;
            scene.remove(selected);
            const index = objects.indexOf(selected);
            if (index > -1) objects.splice(index, 1);
          }
        }
      }, false);
      
      // ANIMATION / GAME LOOP
      function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = (time - prevTime) / 1000;
      
        if (controls.isLocked) {
          // Apply friction and gravity
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          velocity.y -= 9.8 * 10.0 * delta;
      
          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize();
      
          if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
      
          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);
          controls.getObject().position.y += velocity.y * delta;
      
          // Prevent falling below the ground level.
          if (controls.getObject().position.y < 2) {
            velocity.y = 0;
            controls.getObject().position.y = 2;
            canJump = true;
          }
        }
      
        prevTime = time;
        renderer.render(scene, camera);
      }
      
      animate();
      
      // Handle window resize events.
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }, false);
    </script>
  </body>
</html>
