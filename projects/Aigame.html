<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Retro Mario-Inspired Platformer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #87CEEB; /* default sky blue; individual levels override this */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    /********************************************
     * Global Variables and Setup
     ********************************************/
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    // Game state: "menu", "play", "win"
    let gameState = "menu";
    let currentLevelIndex = 0;
    let currentLevel = null;
    
    // Camera horizontal offset (for side scrolling)
    let cameraX = 0;
    
    // Physics constants
    const GRAVITY = 2000;      // pixels per second²
    const PLAYER_SPEED = 250;  // horizontal movement speed
    const JUMP_VELOCITY = -800;// initial jump velocity
    
    // Time tracking
    let lastFrameTime = performance.now();
    
    // Key input state
    const keys = {};
    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);
    
    /********************************************
     * Player Object – Retro Mario Look
     ********************************************/
    let player = {
      // Position and dimensions
      x: 50,
      y: 440,
      width: 40,
      height: 60,
      vx: 0,
      vy: 0,
      onGround: false,
      reset: function() {
        this.x = currentLevel.playerStart.x;
        this.y = currentLevel.playerStart.y;
        this.vx = 0;
        this.vy = 0;
        this.onGround = false;
      }
    };
    
    /********************************************
     * Level Globals (set at level load)
     ********************************************/
    let levelWidth = 3000;
    let platforms = [];  // Array of platform objects: { x, y, w, h }
    let enemies = [];    // Array of enemy objects: { x, y, w, h, vx, vy }
    let flag = null;     // Flag object: { x, y, w, h }
    let boss = null;     // Boss object (if any): { x, y, w, h, hp, vx }
    
    /********************************************
     * Level Definitions
     * Each level includes:
     *   - name, type, levelWidth, backgroundColor
     *   - playerStart: {x, y}
     *   - platforms: array of { x, y, w, h }
     *   - enemies: array of { x, y, w, h, vx }
     *   - flag: { x, y, w, h }
     *   - boss: null or an object (for castle level)
     ********************************************/
    const levels = [
      // Level 0: Bright Overworld (World 1-1)
      {
        name: "World 1-1",
        type: "overworld",
        levelWidth: 3000,
        backgroundColor: "#87CEEB", // sky blue
        playerStart: { x: 50, y: 440 },
        platforms: [
          { x: 0,    y: 500, w: 3000, h: 100 },
          { x: 300,  y: 400, w: 150,  h: 20 },
          { x: 600,  y: 350, w: 150,  h: 20 },
          { x: 900,  y: 300, w: 150,  h: 20 },
          { x: 1200, y: 400, w: 200,  h: 20 },
          { x: 1600, y: 350, w: 150,  h: 20 },
          { x: 2000, y: 300, w: 150,  h: 20 },
          { x: 2400, y: 350, w: 150,  h: 20 }
        ],
        enemies: [
          { x: 500,  y: 440, w: 40, h: 40, vx: 50, vy: 0 },
          { x: 1300, y: 360, w: 40, h: 40, vx: -50, vy: 0 },
          { x: 2100, y: 260, w: 40, h: 40, vx: 60, vy: 0 }
        ],
        flag: { x: 2900, y: 350, w: 20, h: 150 },
        boss: null
      },
      // Level 1: Underground
      {
        name: "World Underground",
        type: "underground",
        levelWidth: 2500,
        backgroundColor: "#303030", // dark, stone-like
        playerStart: { x: 50, y: 440 },
        platforms: [
          { x: 0,    y: 500, w: 2500, h: 100 },
          { x: 400,  y: 420, w: 150, h: 20 },
          { x: 800,  y: 380, w: 150, h: 20 },
          { x: 1200, y: 430, w: 150, h: 20 },
          { x: 1600, y: 370, w: 150, h: 20 }
        ],
        enemies: [
          { x: 600,  y: 440, w: 40, h: 40, vx: 40, vy: 0 },
          { x: 1400, y: 350, w: 40, h: 40, vx: -40, vy: 0 }
        ],
        flag: { x: 2400, y: 350, w: 20, h: 150 },
        boss: null
      },
      // Level 2: Castle (with a Boss Fight)
      {
        name: "World Castle",
        type: "castle",
        levelWidth: 2000,
        backgroundColor: "#4F4F4F", // grayish castle background
        playerStart: { x: 50, y: 440 },
        platforms: [
          { x: 0,    y: 500, w: 2000, h: 100 },
          { x: 300,  y: 420, w: 150,  h: 20 },
          { x: 600,  y: 380, w: 150,  h: 20 },
          { x: 900,  y: 340, w: 150,  h: 20 },
          { x: 1200, y: 400, w: 200,  h: 20 }
        ],
        enemies: [
          { x: 700,  y: 440, w: 40, h: 40, vx: 50, vy: 0 },
          { x: 1100, y: 350, w: 40, h: 40, vx: -50, vy: 0 }
        ],
        flag: { x: 1900, y: 350, w: 20, h: 150 },
        // The boss is placed before the flag; it must be stomped 3 times.
        boss: { x: 1600, y: 360, w: 80, h: 80, hp: 3, vx: 0 }
      }
    ];
    
    /********************************************
     * Level Loading Function
     ********************************************/
    function loadLevel(index) {
      currentLevelIndex = index;
      currentLevel = levels[index];
      levelWidth = currentLevel.levelWidth;
      // Clone platforms, enemies, flag, and boss from the level definition
      platforms = currentLevel.platforms.map(p => ({ ...p }));
      enemies = currentLevel.enemies.map(e => ({ ...e }));
      flag = { ...currentLevel.flag };
      boss = currentLevel.boss ? { ...currentLevel.boss } : null;
      
      // Reset player and camera
      player.x = currentLevel.playerStart.x;
      player.y = currentLevel.playerStart.y;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;
      cameraX = 0;
      gameState = "play";
    }
    
    /********************************************
     * Collision Detection Helper
     ********************************************/
    function rectIntersect(r1, r2) {
      return !(r2.x > r1.x + r1.w ||
               r2.x + r2.w < r1.x ||
               r2.y > r1.y + r1.h ||
               r2.y + r2.h < r1.y);
    }
    
    /********************************************
     * Update Function – Physics & Collisions
     ********************************************/
    function update(dt) {
      // --- Player Input & Movement ---
      if (keys["ArrowLeft"] || keys["KeyA"]) {
        player.vx = -PLAYER_SPEED;
      } else if (keys["ArrowRight"] || keys["KeyD"]) {
        player.vx = PLAYER_SPEED;
      } else {
        player.vx = 0;
      }
      if ((keys["ArrowUp"] || keys["Space"] || keys["KeyW"]) && player.onGround) {
        player.vy = JUMP_VELOCITY;
        player.onGround = false;
      }
      
      // Apply gravity to player
      player.vy += GRAVITY * dt;
      
      // Update player position
      player.x += player.vx * dt;
      player.y += player.vy * dt;
      
      // Check collision with platforms for player
      player.onGround = false;
      const playerRect = { x: player.x, y: player.y, w: player.width, h: player.height };
      for (const plat of platforms) {
        const platRect = { x: plat.x, y: plat.y, w: plat.w, h: plat.h };
        if (rectIntersect(playerRect, platRect)) {
          // Land on platform if falling onto it
          if (player.vy > 0 && player.y + player.height - player.vy * dt <= plat.y + 5) {
            player.y = plat.y - player.height;
            player.vy = 0;
            player.onGround = true;
          } else {
            // Basic horizontal collision resolution
            if (player.x < plat.x) {
              player.x = plat.x - player.width;
            } else if (player.x > plat.x + plat.w) {
              player.x = plat.x + plat.w;
            }
          }
        }
      }
      
      // Reset player if falling off the level
      if (player.y > canvas.height) {
        player.reset();
      }
      
      // --- Update Enemies ---
      for (const enemy of enemies) {
        enemy.x += enemy.vx * dt;
        enemy.vy += GRAVITY * dt;
        enemy.y += enemy.vy * dt;
        const enemyRect = { x: enemy.x, y: enemy.y, w: enemy.w, h: enemy.h };
        for (const plat of platforms) {
          const platRect = { x: plat.x, y: plat.y, w: plat.w, h: plat.h };
          if (rectIntersect(enemyRect, platRect)) {
            if (enemy.vy > 0 && enemy.y + enemy.h - enemy.vy * dt <= plat.y + 5) {
              enemy.y = plat.y - enemy.h;
              enemy.vy = 0;
            }
          }
        }
        // Reverse enemy direction at level boundaries
        if (enemy.x < 0 || enemy.x > levelWidth - enemy.w) {
          enemy.vx = -enemy.vx;
        }
        // Check enemy collision with player: if stomping, remove enemy; otherwise reset player
        if (rectIntersect(playerRect, enemyRect)) {
          if (player.vy > 0 && player.y + player.height - player.vy * dt <= enemy.y + 10) {
            enemy.x = -1000; // remove enemy
            player.vy = JUMP_VELOCITY * 0.5;
          } else {
            player.reset();
          }
        }
      }
      
      // --- Update Boss (if any) ---
      if (boss) {
        const bossRect = { x: boss.x, y: boss.y, w: boss.w, h: boss.h };
        if (rectIntersect(playerRect, bossRect)) {
          if (player.vy > 0 && player.y + player.height - player.vy * dt <= boss.y + 10) {
            boss.hp--;
            player.vy = JUMP_VELOCITY * 0.5;
            if (boss.hp <= 0) {
              boss.x = -1000; // Remove boss when defeated
            }
          } else {
            player.reset();
          }
        }
      }
      
      // --- Check for Win Condition (Flag) ---
      if (rectIntersect(playerRect, flag)) {
        if (currentLevelIndex < levels.length - 1) {
          loadLevel(currentLevelIndex + 1);
        } else {
          gameState = "win";
        }
      }
      
      // --- Update Camera Position (Follow Player) ---
      cameraX = player.x - canvas.width / 2;
      if (cameraX < 0) cameraX = 0;
      if (cameraX > levelWidth - canvas.width) cameraX = levelWidth - canvas.width;
    }
    
    /********************************************
     * Drawing Functions
     ********************************************/
    function drawMenu() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#FFF";
      ctx.font = "40px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Retro Mario-Inspired Platformer", canvas.width / 2, 100);
      ctx.font = "30px Arial";
      const startY = 200;
      const spacing = 50;
      for (let i = 0; i < levels.length; i++) {
        ctx.fillStyle = "#FFD700";
        ctx.fillText(levels[i].name, canvas.width / 2, startY + i * spacing);
      }
      ctx.font = "20px Arial";
      ctx.fillStyle = "#FFF";
      ctx.fillText("Click a level to play", canvas.width / 2, startY + levels.length * spacing + 40);
    }
    
    function drawGame() {
      // Fill background with the current level's background color
      ctx.fillStyle = currentLevel.backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.save();
      // Translate context by the camera's horizontal offset
      ctx.translate(-cameraX, 0);
      
      // Draw platforms
      for (const plat of platforms) {
        if (currentLevel.type === "underground") {
          ctx.fillStyle = "#8B4513"; // brick-like tone underground
        } else if (currentLevel.type === "castle") {
          ctx.fillStyle = "#555"; // stone-like for castle
        } else {
          ctx.fillStyle = "#228B22"; // green ground for overworld
        }
        ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
      }
      
      // Draw the flag (a pole and a flag)
      ctx.fillStyle = "#FF0000";
      ctx.fillRect(flag.x - 10, flag.y, 10, flag.h);
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(flag.x, flag.y, flag.w, flag.h);
      
      // Draw the player with retro styling
      // Body (red rectangle)
      ctx.fillStyle = "#FF0000";
      ctx.fillRect(player.x, player.y, player.width, player.height);
      // Cap (a red arc on top)
      ctx.fillStyle = "#FF0000";
      ctx.beginPath();
      ctx.arc(player.x + player.width/2, player.y + 10, 20, Math.PI, 2 * Math.PI);
      ctx.fill();
      // Overalls (blue rectangle on lower half)
      ctx.fillStyle = "#0000FF";
      ctx.fillRect(player.x, player.y + player.height/2, player.width, player.height/2);
      
      // Draw enemies
      for (const enemy of enemies) {
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(enemy.x, enemy.y, enemy.w, enemy.h);
      }
      
      // Draw the boss (if present)
      if (boss && boss.hp > 0) {
        ctx.fillStyle = "#B22222";
        ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
        ctx.fillStyle = "#FFF";
        ctx.font = "20px Arial";
        ctx.fillText("HP: " + boss.hp, boss.x, boss.y - 10);
      }
      
      ctx.restore();
    }
    
    function drawWin() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#FFF";
      ctx.font = "50px Arial";
      ctx.textAlign = "center";
      ctx.fillText("You Win!", canvas.width / 2, canvas.height / 2);
    }
    
    /********************************************
     * Mouse Click to Select Level (Menu)
     ********************************************/
    canvas.addEventListener("click", function(e) {
      if (gameState === "menu") {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const startY = 200;
        const spacing = 50;
        for (let i = 0; i < levels.length; i++) {
          let textY = startY + i * spacing;
          if (mouseY > textY - 30 && mouseY < textY + 10) {
            loadLevel(i);
            break;
          }
        }
      } else if (gameState === "win") {
        // Restart the game by returning to menu
        gameState = "menu";
      }
    });
    
    /********************************************
     * Main Game Loop
     ********************************************/
    function gameLoop(currentTime) {
      const dt = (currentTime - lastFrameTime) / 1000;
      lastFrameTime = currentTime;
      if (gameState === "play") {
        update(dt);
        drawGame();
      } else if (gameState === "menu") {
        drawMenu();
      } else if (gameState === "win") {
        drawWin();
      }
      requestAnimationFrame(gameLoop);
    }
    
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
