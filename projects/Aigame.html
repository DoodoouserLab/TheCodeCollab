<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Classic Mario–Style Platformer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #5c94fc; /* a blue-ish backdrop outside the canvas */
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #87CEEB; /* sky-blue background */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    /********************************************
     * Global Constants, Variables, and Setup
     ********************************************/
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Level dimensions – for a long level (in pixels)
    const levelWidth = 3000; // the entire level is 3000px wide
    const levelHeight = 600; // same as canvas height

    // Physics constants
    const GRAVITY = 2000; // pixels per second^2
    const PLAYER_SPEED = 250;
    const JUMP_VELOCITY = -800;

    // Input state
    const keys = {};
    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);

    // Camera offset in X (cameraY is fixed since our level is flat vertically)
    let cameraX = 0;

    // Game state: "play" or "win"
    let gameState = "play";

    // Time tracking
    let lastTime = performance.now();

    /********************************************
     * Player Object – A Retro Mario‐Inspired Look
     ********************************************/
    const player = {
      x: 50,
      y: 0,       // will fall onto platforms
      width: 40,
      height: 60,
      vx: 0,
      vy: 0,
      onGround: false,
      reset() {
        this.x = 50;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.onGround = false;
      }
    };

    /********************************************
     * Platforms – Ground and Floating Platforms
     ********************************************/
    // Each platform is an object: { x, y, w, h }
    const platforms = [];
    // Ground platform extends the entire level.
    platforms.push({ x: 0, y: 500, w: levelWidth, h: 100 });
    // Floating platforms at various positions:
    platforms.push({ x: 300,  y: 400, w: 150, h: 20 });
    platforms.push({ x: 600,  y: 350, w: 150, h: 20 });
    platforms.push({ x: 900,  y: 300, w: 150, h: 20 });
    platforms.push({ x: 1200, y: 400, w: 200, h: 20 });
    platforms.push({ x: 1600, y: 350, w: 150, h: 20 });
    platforms.push({ x: 1900, y: 300, w: 150, h: 20 });
    platforms.push({ x: 2200, y: 350, w: 150, h: 20 });
    platforms.push({ x: 2500, y: 400, w: 150, h: 20 });
    platforms.push({ x: 2800, y: 300, w: 150, h: 20 });

    /********************************************
     * Enemies – Simple Roaming Foes
     ********************************************/
    // Each enemy is represented as an object: { x, y, width, height, vx, vy }
    const enemies = [];
    enemies.push({ x: 500,  y: 440, width: 40, height: 40, vx: 50, vy: 0 });
    enemies.push({ x: 1300, y: 360, width: 40, height: 40, vx: -50, vy: 0 });
    enemies.push({ x: 2100, y: 260, width: 40, height: 40, vx: 60, vy: 0 });
    enemies.push({ x: 2600, y: 360, width: 40, height: 40, vx: -60, vy: 0 });

    /********************************************
     * Flag – Reaching the End Wins the Game!
     ********************************************/
    const flag = {
      x: levelWidth - 100,
      y: 200,
      width: 20,
      height: 300
    };

    /********************************************
     * Collision Detection Helper Function
     ********************************************/
    function rectIntersect(r1, r2) {
      return !(r2.x > r1.x + r1.w ||
               r2.x + r2.w < r1.x ||
               r2.y > r1.y + r1.h ||
               r2.y + r2.h < r1.y);
    }

    /********************************************
     * Update Function (Physics, Movement, etc.)
     ********************************************/
    function update(dt) {
      // --- Player movement (controls) ---
      if (keys["ArrowLeft"] || keys["KeyA"]) {
        player.vx = -PLAYER_SPEED;
      } else if (keys["ArrowRight"] || keys["KeyD"]) {
        player.vx = PLAYER_SPEED;
      } else {
        player.vx = 0;
      }

      if ((keys["Space"] || keys["ArrowUp"] || keys["KeyW"]) && player.onGround) {
        player.vy = JUMP_VELOCITY;
        player.onGround = false;
      }

      // Apply gravity to player
      player.vy += GRAVITY * dt;

      // Update player position
      player.x += player.vx * dt;
      player.y += player.vy * dt;

      // --- Platform Collision for the Player ---
      // We use a simple AABB collision check
      player.onGround = false;
      const playerRect = { x: player.x, y: player.y, w: player.width, h: player.height };
      for (const plat of platforms) {
        const platRect = { x: plat.x, y: plat.y, w: plat.w, h: plat.h };
        if (rectIntersect(playerRect, platRect)) {
          // If falling down and the previous bottom was above the platform, land on it.
          if (player.vy > 0 && (player.y + player.height - player.vy * dt) <= plat.y + 5) {
            player.y = plat.y - player.height;
            player.vy = 0;
            player.onGround = true;
          } else {
            // Collisions from the side (push player away)
            if (player.x < plat.x) {
              player.x = plat.x - player.width;
            } else if (player.x > plat.x + plat.w) {
              player.x = plat.x + plat.w;
            }
          }
        }
      }

      // Reset player if they fall off the level.
      if (player.y > canvas.height) {
        player.reset();
      }

      // --- Update Enemies ---
      for (const enemy of enemies) {
        // Move enemy horizontally.
        enemy.x += enemy.vx * dt;
        // Apply a little gravity.
        enemy.vy = (enemy.vy || 0) + GRAVITY * dt;
        enemy.y += enemy.vy * dt;

        // Check collision with platforms for enemy.
        const enemyRect = { x: enemy.x, y: enemy.y, w: enemy.width, h: enemy.height };
        for (const plat of platforms) {
          const platRect = { x: plat.x, y: plat.y, w: plat.w, h: plat.h };
          if (rectIntersect(enemyRect, platRect)) {
            if (enemy.vy > 0 && (enemy.y + enemy.height - enemy.vy * dt) <= plat.y + 5) {
              enemy.y = plat.y - enemy.height;
              enemy.vy = 0;
            }
          }
        }
        // Reverse direction if enemy hits level boundaries.
        if (enemy.x < 0 || enemy.x > levelWidth - enemy.width) {
          enemy.vx = -enemy.vx;
        }
      }

      // --- Enemy and Player Collision ---
      for (const enemy of enemies) {
        const enemyRect = { x: enemy.x, y: enemy.y, w: enemy.width, h: enemy.height };
        if (rectIntersect(playerRect, enemyRect)) {
          // If the player is falling on the enemy, stomp it.
          if (player.vy > 0 && (player.y + player.height - player.vy * dt) <= enemy.y + 10) {
            // "Stomp" – remove enemy by moving it out of play.
            enemy.x = -1000;
            player.vy = JUMP_VELOCITY * 0.5;
          } else {
            // Otherwise, reset the player.
            player.reset();
          }
        }
      }

      // --- Check the Flag for Win Condition ---
      const flagRect = { x: flag.x, y: flag.y, w: flag.width, h: flag.height };
      if (rectIntersect(playerRect, flagRect)) {
        gameState = "win";
      }

      // --- Update Camera (Horizontal Scroll) ---
      cameraX = player.x - canvas.width / 2;
      if (cameraX < 0) cameraX = 0;
      if (cameraX > levelWidth - canvas.width) cameraX = levelWidth - canvas.width;
    }

    /********************************************
     * Draw Function – Render the Scene
     ********************************************/
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (gameState === "play") {
        // Draw background
        ctx.fillStyle = "#87CEEB";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
  
        ctx.save();
        // Translate drawing by the camera offset.
        ctx.translate(-cameraX, 0);
  
        // Draw ground and platforms
        for (const plat of platforms) {
          // Ground is green; floating platforms are brown.
          if (plat.y === 500 && plat.w === levelWidth)
            ctx.fillStyle = "#228B22"; // ground
          else
            ctx.fillStyle = "#654321"; // platform
          ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
        }
  
        // Draw the flag (a white pole and red flag)
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(flag.x - 10, flag.y, 10, flag.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(flag.x, flag.y, flag.width, flag.height);
  
        // Draw the player with a Mario–inspired look.
        // Base rectangle for the body.
        ctx.fillStyle = "#FF0000"; // red torso
        ctx.fillRect(player.x, player.y, player.width, player.height);
        // Cap: a red arc on top of the player's head.
        ctx.fillStyle = "#FF0000";
        ctx.beginPath();
        ctx.arc(player.x + player.width/2, player.y + 10, 20, Math.PI, 2*Math.PI);
        ctx.fill();
        // Overalls: a blue rectangle on the lower half.
        ctx.fillStyle = "#0000FF";
        ctx.fillRect(player.x, player.y + player.height/2, player.width, player.height/2);
  
        // Draw enemies
        for (const enemy of enemies) {
          ctx.fillStyle = "#8B4513";
          ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        }
  
        ctx.restore();
      } else if (gameState === "win") {
        // Display win screen.
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#FFF";
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText("You Win!", canvas.width / 2, canvas.height / 2);
        ctx.font = "20px Arial";
        ctx.fillText("Refresh the page to play again.", canvas.width / 2, canvas.height / 2 + 40);
      }
    }

    /********************************************
     * Main Game Loop
     ********************************************/
    function gameLoop(currentTime) {
      const dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
  
      if (gameState === "play") {
        update(dt);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }
  
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
