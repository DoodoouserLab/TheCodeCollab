<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Simplified Minecraft Demo</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
        image-rendering: pixelated;
        background: #87CEEB;
      }
      #hud {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-family: "Courier New", monospace;
        color: #fff;
        background: rgba(0,0,0,0.5);
        padding: 8px 12px;
        border: 2px solid #555;
      }
      #instructions {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-family: sans-serif;
        color: #fff;
        background: rgba(0,0,0,0.5);
        padding: 8px 12px;
        border: 2px solid #555;
      }
    </style>
    <!-- Load Three.js and PointerLockControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
  </head>
  <body>
    <div id="hud"></div>
    <div id="instructions">
      Click to lock pointer. WASD to move; use mouse to look.<br>
      Left–click to mine, right–click to place block.<br>
      Number keys 1–3 select block type for placement:<br>
      1 = Stone, 2 = Dirt, 3 = Grass.
    </div>
    <script>
      /***** SETUP SCENE, CAMERA, RENDERER *****/
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // sky blue
      
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      // We'll let the controls handle the camera position.
      
      const renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      /***** POINTER LOCK CONTROLS *****/
      const controls = new THREE.PointerLockControls(camera, document.body);
      scene.add( controls.getObject() );
      
      // When the user clicks on the canvas, lock the pointer.
      document.addEventListener("click", () => {
        controls.lock();
      });
      
      /***** PLAYER MOVEMENT VARIABLES *****/
      const move = { forward: false, backward: false, left: false, right: false };
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const clock = new THREE.Clock();
      
      document.addEventListener("keydown", function(e) {
        switch(e.code) {
          case "KeyW": move.forward = true; break;
          case "KeyS": move.backward = true; break;
          case "KeyA": move.left = true; break;
          case "KeyD": move.right = true; break;
          // Use number keys 1-3 to select block type for placement.
          case "Digit1": selectedSlot = 0; break;
          case "Digit2": selectedSlot = 1; break;
          case "Digit3": selectedSlot = 2; break;
        }
      });
      document.addEventListener("keyup", function(e) {
        switch(e.code) {
          case "KeyW": move.forward = false; break;
          case "KeyS": move.backward = false; break;
          case "KeyA": move.left = false; break;
          case "KeyD": move.right = false; break;
        }
      });
      
      /***** BUILD A SIMPLE VOXEL WORLD *****/
      // World dimensions in blocks (a small demo chunk)
      const WORLD_SIZE_X = 16, WORLD_SIZE_Y = 8, WORLD_SIZE_Z = 16;
      // We'll represent the world as a dictionary keyed by "x_y_z" mapping to block type.
      // Block types: 0 = air; 1 = stone; 2 = dirt; 3 = grass.
      let worldData = {};
      // Create a flat world with some variation:
      for (let x = 0; x < WORLD_SIZE_X; x++) {
        for (let z = 0; z < WORLD_SIZE_Z; z++) {
          // For each (x,z), define ground height between 3 and 4:
          const ground = 3 + Math.floor(Math.random() * 2);
          for (let y = 0; y < WORLD_SIZE_Y; y++) {
            const key = `${x}_${y}_${z}`;
            if (y < ground - 1) {
              worldData[key] = 1;  // stone layer
            } else if (y < ground) {
              worldData[key] = 2;  // dirt layer
            } else if (y === ground) {
              worldData[key] = 3;  // grass on top
            } else {
              worldData[key] = 0;  // air above
            }
          }
        }
      }
      
      // A THREE.Group to hold voxel cubes.
      const worldGroup = new THREE.Group();
      scene.add(worldGroup);
      
      // Materials for block types.
      const voxelMaterials = {
        1: new THREE.MeshLambertMaterial({ color: 0x808080 }), // stone (gray)
        2: new THREE.MeshLambertMaterial({ color: 0x8B4513 }), // dirt (brown)
        3: new THREE.MeshLambertMaterial({ color: 0x228B22 })  // grass (green)
      };
      
      const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
      
      function addVoxel(x, y, z, type) {
        if (type === 0) return;
        const mat = voxelMaterials[type];
        if (!mat) return;
        const cube = new THREE.Mesh(cubeGeo, mat);
        cube.position.set(x + 0.5, y + 0.5, z + 0.5);
        // Save its grid position for later removal.
        cube.userData = { pos: { x: x, y: y, z: z } };
        worldGroup.add(cube);
      }
      
      // Build the world from worldData.
      function buildWorld() {
        worldGroup.clear();
        for (let key in worldData) {
          let type = worldData[key];
          if (type !== 0) {
            const parts = key.split("_").map(Number);
            addVoxel(parts[0], parts[1], parts[2], type);
          }
        }
      }
      buildWorld();
      
      /***** LIGHTING *****/
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      scene.add(directionalLight);
      
      /***** INVENTORY SETUP *****/
      // Our inventory corresponds to placeable block types.
      // Inventory order: index 0 = stone, 1 = dirt, 2 = grass.
      const inventoryData = {
        stone: 100,
        dirt: 100,
        grass: 100,
        gel: 0
      };
      const inventoryOrder = ["stone", "dirt", "grass"];
      let selectedSlot = 0;
      
      const hudDiv = document.getElementById("hud");
      function updateHUD() {
        let hudText = "Inventory: ";
        inventoryOrder.forEach((item, i) => {
          if (i === selectedSlot)
            hudText += `[${item}: ${inventoryData[item]}] `;
          else
            hudText += `${item}: ${inventoryData[item]} `;
        });
        hudDiv.textContent = hudText;
      }
      updateHUD();
      
      /***** RAYCASTER FOR MINING/PLACING *****/
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      // For our purposes, we will use the center of the screen, i.e. (0,0) in NDC.
      
      // Left-click (mine block)
      window.addEventListener("mousedown", function(e) {
        // If left button:
        if (e.button === 0 && controls.isLocked) {
          raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
          const intersects = raycaster.intersectObjects(worldGroup.children);
          if (intersects.length > 0) {
            const hit = intersects[0];
            const pos = hit.object.userData.pos;
            const key = `${pos.x}_${pos.y}_${pos.z}`;
            // Add block to inventory (for simplicity, add 1 unit)
            let type = worldData[key];
            if (type === 1) inventoryData.stone += 1;
            else if (type === 2) inventoryData.dirt += 1;
            else if (type === 3) inventoryData.grass += 1;
            worldData[key] = 0;
            worldGroup.remove(hit.object);
            updateHUD();
          }
        }
      });
      
      // Right-click (place block)
      window.addEventListener("contextmenu", function(e) {
        e.preventDefault();
        if (!controls.isLocked) return;
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        const intersects = raycaster.intersectObjects(worldGroup.children);
        let placePos = null;
        if(intersects.length > 0) {
          const hit = intersects[0];
          const pos = hit.object.userData.pos;
          const normal = hit.face.normal;
          placePos = {
            x: pos.x + (normal.x > 0.5 ? 1 : (normal.x < -0.5 ? -1 : 0)),
            y: pos.y + (normal.y > 0.5 ? 1 : (normal.y < -0.5 ? -1 : 0)),
            z: pos.z + (normal.z > 0.5 ? 1 : (normal.z < -0.5 ? -1 : 0))
          };
        } else {
          // If no block was hit, place a block 3 units ahead of the camera.
          const dir = new THREE.Vector3();
          camera.getWorldDirection(dir);
          const pos = controls.getObject().position.clone().add(dir.multiplyScalar(3));
          placePos = {
            x: Math.floor(pos.x),
            y: Math.floor(pos.y),
            z: Math.floor(pos.z)
          };
        }
        const key = `${placePos.x}_${placePos.y}_${placePos.z}`;
        if (worldData[key] === 0) { // only place if space empty
          const sel = inventoryOrder[selectedSlot];
          if (inventoryData[sel] > 0) {
            // Map inventory selection to block type. We choose: stone->1, dirt->2, grass->3.
            let blockType = 0;
            if (sel === "stone") blockType = 1;
            else if (sel === "dirt") blockType = 2;
            else if (sel === "grass") blockType = 3;
            worldData[key] = blockType;
            addVoxel(placePos.x, placePos.y, placePos.z, blockType);
            inventoryData[sel]--;
            updateHUD();
          }
        }
      });
      
      /***** ANIMATION (MOVEMENT & RENDER) *****/
      const clockMovement = new THREE.Clock();
      function animate() {
        const delta = clockMovement.getDelta();
        if (controls.isLocked === true) {
          // Update movement velocity.
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          
          direction.z = Number(move.forward) - Number(move.backward);
          direction.x = Number(move.right) - Number(move.left);
          direction.normalize();
          
          if (move.forward || move.backward) velocity.z -= direction.z * 400.0 * delta;
          if (move.left || move.right) velocity.x -= direction.x * 400.0 * delta;
          
          controls.moveRight(- velocity.x * delta);
          controls.moveForward(- velocity.z * delta);
        }
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
      
      /***** WINDOW RESIZE *****/
      window.addEventListener("resize", function() {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      /***** NOTES *****
      - This is a very rudimentary demo. The voxel world is tiny and fixed.
      - Movement is handled by PointerLockControls—you must click the screen for pointer lock.
      - Mining and block placement use raycasting from the center of the view.
      - The block textures, world generation, physics, and inventory are extremely simplified.
      - You can extend this by improving world generation, adding textures, and expanding inventory/crafting.
      */
    </script>
  </body>
</html>
