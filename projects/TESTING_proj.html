<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PointerLock Movement Test</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
      }
      #instructions {
        position: absolute;
        top: 0;
        width: 100%;
        text-align: center;
        font-family: sans-serif;
        color: white;
        pointer-events: none;
      }
    </style>
    <!-- Load Three.js and PointerLockControls from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
  </head>
  <body>
    <div id="instructions">Click to lock pointer. Use WASD to move and mouse to look.</div>
    <script>
      // Setup scene, camera, renderer
      let scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);  // sky blue

      let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 10, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add a flat ground for reference
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Add ambient and directional lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(0, 50, 50);
      scene.add(directionalLight);

      // Setup PointerLockControls
      const controls = new THREE.PointerLockControls(camera, document.body);
      scene.add(controls.getObject());

      // When the pointer is locked, hide instructions.
      document.addEventListener("pointerlockchange", function() {
        if(document.pointerLockElement === document.body) {
          document.getElementById("instructions").style.display = "none";
        } else {
          document.getElementById("instructions").style.display = "";
        }
      }, false);

      // Click to lock the pointer.
      document.body.addEventListener("click", () => {
        controls.lock();
      }, false);

      // Movement variables
      const move = { forward: false, backward: false, left: false, right: false };
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const clock = new THREE.Clock();

      // keyboard input events
      document.addEventListener("keydown", function(e) {
        switch(e.code) {
          case "KeyW": move.forward = true; break;
          case "KeyS": move.backward = true; break;
          case "KeyA": move.left = true; break;
          case "KeyD": move.right = true; break;
        }
      });
      document.addEventListener("keyup", function(e) {
        switch(e.code) {
          case "KeyW": move.forward = false; break;
          case "KeyS": move.backward = false; break;
          case "KeyA": move.left = false; break;
          case "KeyD": move.right = false; break;
        }
      });

      // Animation loop: update movement and render
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        if (controls.isLocked === true) {
          // Apply friction
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          // Determine movement direction
          direction.z = Number(move.forward) - Number(move.backward);
          direction.x = Number(move.right) - Number(move.left);
          direction.normalize();
          // Accelerate based on input
          if (move.forward || move.backward) velocity.z -= direction.z * 400.0 * delta;
          if (move.left || move.right) velocity.x -= direction.x * 400.0 * delta;
          // Move at the updated velocity
          controls.moveRight(- velocity.x * delta);
          controls.moveForward(- velocity.z * delta);
        }
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
