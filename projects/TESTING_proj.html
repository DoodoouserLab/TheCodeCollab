<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini Minecraft in HTML (Simplified Voxel Demo)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      background: #87CEEB;
    }
    #inventory {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border: 2px solid #555;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="inventory"></div>
  <script>
    /***** Canvas Setup *****/
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    /***** World Setup *****/
    // Our world is a 2D grid of blocks.
    const WORLD_WIDTH = 50, WORLD_HEIGHT = 50;
    const world = [];
    // Generate terrain with a random ground height per column.
    for (let x = 0; x < WORLD_WIDTH; x++) {
      world[x] = [];
      // Ground height between 10 and 15 (for a low, playable terrain)
      let groundHeight = 10 + Math.floor(Math.random() * 6);
      for (let y = 0; y < WORLD_HEIGHT; y++) {
        if (y < groundHeight) {
          world[x][y] = 0;  // Air (empty)
        } else if (y === groundHeight) {
          world[x][y] = 3;  // Grass on the surface
        } else {
          // Underground: 70% dirt, 30% stone
          world[x][y] = (Math.random() < 0.7) ? 1 : 2;
        }
      }
    }
    // Carve caves: for several starting points, remove blocks in an irregular tunnel.
    for (let i = 0; i < 10; i++) {
      let cx = Math.floor(Math.random() * WORLD_WIDTH);
      let cy = 15 + Math.floor(Math.random() * (WORLD_HEIGHT - 20));
      for (let j = 0; j < 20; j++) {
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            let nx = cx + dx, ny = cy + dy;
            if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) {
              world[nx][ny] = 0;
            }
          }
        }
        cx += Math.floor(Math.random() * 3) - 1;
        cy += Math.floor(Math.random() * 3) - 1;
        if(cx < 0 || cx >= WORLD_WIDTH || cy < 0 || cy >= WORLD_HEIGHT) break;
      }
    }

    /***** Block Properties *****/
    // Block types:
    // 0 = Air, 1 = Dirt, 2 = Stone, 3 = Grass
    const blockColors = {
      0: null,
      1: "#8B4513", // Dirt
      2: "#808080", // Stone
      3: "#228B22"  // Grass
    };
    // Durability of blocks (for mining)
    const blockDurability = {
      1: 2,
      2: 3,
      3: 2
    };
    // Track current block "health" (remaining hits); initialize to full durability.
    const blockHealth = [];
    for (let x = 0; x < WORLD_WIDTH; x++) {
      blockHealth[x] = [];
      for (let y = 0; y < WORLD_HEIGHT; y++) {
        let b = world[x][y];
        blockHealth[x][y] = (b !== 0 && blockDurability[b] !== undefined) ? blockDurability[b] : 0;
      }
    }
    function setBlock(x, y, b) {
      if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) return;
      world[x][y] = b;
      if (b !== 0 && blockDurability[b] !== undefined)
        blockHealth[x][y] = blockDurability[b];
      else
        blockHealth[x][y] = 0;
    }

    /***** Player Setup *****/
    // Player position in world (tile coordinates, float)
    let playerX = 25, playerY = 7;
    // For isometric view, no rotation will be implemented (fixed topâ€“down isometric).
    // Our "player" is simply a point that we draw.
    
    /***** Inventory Setup *****/
    // Inventory holds block resources and tools. Here we consider only blocks:
    // "dirt", "stone", "grass". (You can extend with more types like "wood", etc.)
    const inventory = {
      dirt: 20,
      stone: 20,
      grass: 10,
      gel: 0,  // slime drops
      wooden_pickaxe: 0,
      wooden_sword: 0,
      torch: 0
    };
    // Hotbar order (assign number keys based on index)
    const inventoryOrder = ["dirt", "stone", "grass"];
    let selectedSlot = 0;
    
    /***** Isometric Drawing Helpers *****/
    // We use a simple isometric projection:
    // screenX = (x - y) * (tileW/2); screenY = (x + y) * (tileH/2);
    const tileW = 32, tileH = 16;
    function isoProject(x, y) {
      return {
        x: (x - y) * (tileW / 2),
        y: (x + y) * (tileH / 2)
      };
    }
    // Draw a cube in isometric view at screen coordinates (sx, sy)
    // The cube will have a top face, left face, and right face.
    function drawCube(sx, sy, color) {
      const h = 32; // cube height in pixels
      // Top face
      ctx.fillStyle = lighten(color, 20);
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + tileW/2, sy + tileH/2);
      ctx.lineTo(sx, sy + tileH);
      ctx.lineTo(sx - tileW/2, sy + tileH/2);
      ctx.closePath();
      ctx.fill();
      // Left face
      ctx.fillStyle = darken(color, 20);
      ctx.beginPath();
      ctx.moveTo(sx - tileW/2, sy + tileH/2);
      ctx.lineTo(sx, sy + tileH);
      ctx.lineTo(sx, sy + tileH + h);
      ctx.lineTo(sx - tileW/2, sy + tileH/2 + h);
      ctx.closePath();
      ctx.fill();
      // Right face
      ctx.fillStyle = darken(color, 40);
      ctx.beginPath();
      ctx.moveTo(sx + tileW/2, sy + tileH/2);
      ctx.lineTo(sx, sy + tileH);
      ctx.lineTo(sx, sy + tileH + h);
      ctx.lineTo(sx + tileW/2, sy + tileH/2 + h);
      ctx.closePath();
      ctx.fill();
    }
    // Basic color adjustment functions:
    function lighten(hex, amt) {
      let num = parseInt(hex.slice(1),16);
      let r = Math.min(255, Math.max(0, (num >> 16) + amt));
      let g = Math.min(255, Math.max(0, ((num >> 8) & 0xFF) + amt));
      let b = Math.min(255, Math.max(0, (num & 0xFF) + amt));
      return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, "0");
    }
    function darken(hex, amt) {
      return lighten(hex, -amt);
    }

    /***** Rendering the World (Isometric) *****/
    function drawWorld() {
      // Center the world drawing roughly on the canvas.
      const centerX = canvas.width/2;
      const offsetY = 50; // arbitrary vertical offset
      for (let x = 0; x < WORLD_WIDTH; x++) {
        for (let y = 0; y < WORLD_HEIGHT; y++) {
          const block = world[x][y];
          if (block !== 0) {
            const iso = isoProject(x, y);
            const screenX = iso.x + centerX;
            const screenY = iso.y + offsetY;
            drawCube(screenX, screenY, blockColors[block]);
            // Optional: draw mining progress overlay if any (omitted for brevity)
          }
        }
      }
    }

    /***** Drawing the Player *****/
    function drawPlayer() {
      // Represent the player as a red circle.
      const centerX = canvas.width/2;
      const offsetY = 50;
      const iso = isoProject(playerX, playerY);
      const sx = iso.x + centerX;
      const sy = iso.y + offsetY - 16; // raise a bit to stand on blocks
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(sx, sy, 8, 0, 2*Math.PI);
      ctx.fill();
    }

    /***** Inventory Display *****/
    const invDiv = document.getElementById("inventory");
    function updateInventoryDisplay() {
      let text = "Inventory: ";
      inventoryOrder.forEach((item, i) => {
        if(i === selectedSlot) text += "[" + item + ":" + (inventory[item] || 0) + "] ";
        else text += item + ":" + (inventory[item] || 0) + " ";
      });
      invDiv.textContent = text;
    }

    /***** Input Handling *****/
    // Simple arrow key movement for the player.
    window.addEventListener("keydown", function(e) {
      if (e.key === "ArrowUp") {
        playerX += Math.cos(0) * 0.5;
        playerY += Math.sin(0) * 0.5;
      }
      if (e.key === "ArrowDown") {
        playerX -= Math.cos(0) * 0.5;
        playerY -= Math.sin(0) * 0.5;
      }
      if(e.key === "ArrowLeft") {
        // For simplicity, move diagonally left/up.
        playerX -= 0.5;
        playerY += 0.5;
      }
      if(e.key === "ArrowRight") {
        playerX += 0.5;
        playerY -= 0.5;
      }
      updateInventoryDisplay();
    });

    // Left-click to break a block (using rough inverse isometric conversion)
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      // Inverse isometric: approximate (there are many methods; this is very rough)
      const centerX = canvas.width/2;
      const offsetY = 50;
      // Using simple formulas:
      let tempX = (mx - centerX) / (tileW/2);
      let tempY = (my - offsetY) / (tileH/2);
      // Solve:
      let worldX = (tempX + tempY) / 2;
      let worldY = (tempY - tempX) / 2;
      worldX = Math.floor(worldX);
      worldY = Math.floor(worldY);
      if(worldX >= 0 && worldX < WORLD_WIDTH && worldY >= 0 && worldY < WORLD_HEIGHT) {
        setBlock(worldX, worldY, 0);
      }
    });
    // Right-click to place a block from inventory (selected type)
    canvas.addEventListener("contextmenu", function(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const centerX = canvas.width/2;
      const offsetY = 50;
      let tempX = (mx - centerX) / (tileW/2);
      let tempY = (my - offsetY) / (tileH/2);
      let worldX = (tempX + tempY) / 2;
      let worldY = (tempY - tempX) / 2;
      worldX = Math.floor(worldX);
      worldY = Math.floor(worldY);
      if(worldX >= 0 && worldX < WORLD_WIDTH && worldY >= 0 && worldY < WORLD_HEIGHT) {
        if(world[worldX][worldY] === 0) {
          // Allow placing one of the placeable block types.
          const sel = inventoryOrder[selectedSlot];
          // Only allow if sel is dirt, stone, or grass.
          if(["dirt", "stone", "grass"].includes(sel)) {
            let bt;
            if(sel === "dirt") bt = 1;
            else if(sel === "stone") bt = 2;
            else if(sel === "grass") bt = 3;
            setBlock(worldX, worldY, bt);
            if(inventory[sel] > 0) inventory[sel]--;
          }
        }
      }
      return false;
    });

    /***** Main Game Loop *****/
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Draw sky background
      ctx.fillStyle = "#87CEEB";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      // Draw world and player
      drawWorld();
      drawPlayer();
      updateInventoryDisplay();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();

    /***** Notes on Slime (Enemy) Spawning *****/
    // Due to the complexity of a full 3D engine and entity interaction, this demo does not implement proper 3D enemy rendering.
    // However, you might integrate enemies into the world (for example, using similar isometric drawing routines) and update their behavior.
    // For a complete Minecraft clone, you would need a fully functional voxel engine, physics, and entity system.
  </script>
</body>
</html>
