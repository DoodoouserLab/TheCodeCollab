<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Simple Minecraft Clone in HTML (Very Simplified)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
        background: #000;
        image-rendering: pixelated;
      }
      /* Basic inventory overlay */
      #inventory {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: "Courier New", monospace;
        background: rgba(0, 0, 0, 0.5);
        padding: 4px 8px;
        border: 2px solid #555;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div id="inventory"></div>
    <script>
      /***** Canvas Setup *****/
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      /***** Global Definitions *****/
      // We'll use a 2D grid as our world map.
      // Map dimensions used for the 2.5D raycaster:
      const mapWidth = 16; // number of tiles horizontally
      const mapHeight = 16; // number of tiles vertically
      // The map: 0 = empty; 1 = dirt; 2 = stone; 3 = grass; 4 = wood; 5 = leaves
      const worldMap = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ];

      /***** Player Setup (Raycaster Variables) *****/
      // The player’s position is in "map units" (tile coordinates as float)
      let posX = 8, posY = 8; // start in the center of the map
      // The player’s direction vector
      let dirX = -1, dirY = 0;
      // The 2D camera plane; this determines the field-of-view (FOV)
      let planeX = 0, planeY = 0.66; // FOV ~66 degrees

      // Movement speeds (tweak as needed)
      const moveSpeed = 0.05;
      const rotSpeed = 0.03;

      /***** Inventory Setup *****/
      // Our inventory will hold counts for different block types.
      // For simplicity, we consider:
      // 1 (dirt), 2 (stone), 3 (grass), 4 (wood), 5 (leaves)
      const inventory = {
        dirt: 0,
        stone: 0,
        grass: 0,
        wood: 0,
        leaves: 0,
        // Also tools: e.g. wooden_pickaxe improves mining speed.
        wooden_pickaxe: 0,
        wooden_sword: 0,
        torch: 0
      };
      // Hotbar order (keys 1 to 9)
      const inventoryOrder = ["dirt", "stone", "grass", "wood", "leaves", "wooden_pickaxe", "wooden_sword", "torch"];
      let selectedSlot = 0; // index into inventoryOrder

      // For simplicity, let's pre-populate some resources:
      inventory.dirt = 20;
      inventory.stone = 20;
      inventory.wood = 20;
      inventory.grass = 10;
      inventory.leaves = 10;
      inventory.gel = 0; // gel for slime drops
      // Tools start at zero – you can mine with your hand (slowly)

      /***** 2D Map Collision Helpers *****/
      function mapAt(x, y) {
        if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return 1; // treat out–of–bounds as wall
        return worldMap[Math.floor(x)][Math.floor(y)];
      }
      function setMap(x, y, val) {
        if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return;
        worldMap[Math.floor(x)][Math.floor(y)] = val;
      }

      /***** 2.5D Raycaster Rendering *****/
      function renderScene() {
        const w = canvas.width, h = canvas.height;
        // Draw floor and ceiling
        ctx.fillStyle = "#555"; // ceiling color
        ctx.fillRect(0, 0, w, h / 2);
        ctx.fillStyle = "#333"; // floor color
        ctx.fillRect(0, h / 2, w, h / 2);

        // For every vertical stripe
        for (let x = 0; x < w; x++) {
          // Calculate ray position and direction
          const cameraX = 2 * x / w - 1; // x-coordinate in camera space
          const rayDirX = dirX + planeX * cameraX;
          const rayDirY = dirY + planeY * cameraX;

          // Which box of the map we're in
          let mapX = Math.floor(posX);
          let mapY = Math.floor(posY);

          // Length of ray from current position to next x or y-side
          let sideDistX;
          let sideDistY;

          // Length of ray from one x or y-side to next x or y-side
          const deltaDistX = Math.abs(1 / rayDirX);
          const deltaDistY = Math.abs(1 / rayDirY);
          let perpWallDist;

          // What direction to step in x or y (+1 or -1)
          let stepX, stepY;

          let hit = 0; // was a wall hit?
          let side; // was an NS or a EW wall hit?

          // calculate step and sideDist
          if (rayDirX < 0) {
            stepX = -1;
            sideDistX = (posX - mapX) * deltaDistX;
          } else {
            stepX = 1;
            sideDistX = (mapX + 1.0 - posX) * deltaDistX;
          }
          if (rayDirY < 0) {
            stepY = -1;
            sideDistY = (posY - mapY) * deltaDistY;
          } else {
            stepY = 1;
            sideDistY = (mapY + 1.0 - posY) * deltaDistY;
          }

          // Perform DDA
          while (hit === 0) {
            // jump to next map square, OR in x-direction, OR in y-direction
            if (sideDistX < sideDistY) {
              sideDistX += deltaDistX;
              mapX += stepX;
              side = 0;
            } else {
              sideDistY += deltaDistY;
              mapY += stepY;
              side = 1;
            }
            // Check if ray has hit a wall (nonzero cell)
            if (mapAt(mapX, mapY) > 0) hit = 1;
          }

          // Calculate distance projected on camera direction (Euclidean distance will give fisheye effect!)
          if (side === 0) {
            perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
          } else {
            perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;
          }

          // Calculate height of line to draw on screen
          const lineHeight = Math.floor(h / perpWallDist);

          // calculate lowest and highest pixel to fill in current stripe
          let drawStart = -lineHeight / 2 + h / 2;
          if (drawStart < 0) drawStart = 0;
          let drawEnd = lineHeight / 2 + h / 2;
          if (drawEnd >= h) drawEnd = h - 1;

          // Choose wall color based on map value
          let color;
          const mapVal = mapAt(mapX, mapY);
          if (mapVal === 1) color = "#8B4513"; // dirt
          else if (mapVal === 2) color = "#808080"; // stone
          else if (mapVal === 3) color = "#228B22"; // grass
          else if (mapVal === 4) color = "#A0522D"; // wood
          else if (mapVal === 5) color = "#32CD32"; // leaves
          else color = "#FFFFFF";

          // Give x and y sides different brightness
          if (side === 1) {
            color = darken(color, 0.5);
          }

          // Draw the vertical stripe as a filled rectangle
          ctx.fillStyle = color;
          ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
        }
      }

      // Simple function to darken an HEX color by multiplying each component.
      function darken(hex, factor) {
        // Convert hex to RGB
        let r = parseInt(hex.substr(1, 2), 16);
        let g = parseInt(hex.substr(3, 2), 16);
        let b = parseInt(hex.substr(5, 2), 16);
        r = Math.floor(r * factor);
        g = Math.floor(g * factor);
        b = Math.floor(b * factor);
        return (
          "#" +
          ("0" + r.toString(16)).slice(-2) +
          ("0" + g.toString(16)).slice(-2) +
          ("0" + b.toString(16)).slice(-2)
        );
      }

      /***** Movement and Input *****/
      const keysDown = {};

      window.addEventListener("keydown", function (e) {
        keysDown[e.key] = true;
        // Use number keys 1-n to change selected inventory slot.
        if (!isNaN(e.key) && e.key !== "0") {
          let slot = parseInt(e.key) - 1;
          if (slot < inventoryOrder.length) {
            selectedSlot = slot;
          }
        }
        // Toggle crafting menu with C key (not implemented in full 3D demo)
        if (e.key === "c" || e.key === "C") {
          // For this demo, we omit a crafting menu.
        }
      });

      window.addEventListener("keyup", function (e) {
        keysDown[e.key] = false;
      });

      function updatePlayer() {
        // Move forward/backward
        if (keysDown["w"] || keysDown["W"]) {
          if (mapAt(posX + dirX * moveSpeed, posY) === 0) posX += dirX * moveSpeed;
          if (mapAt(posX, posY + dirY * moveSpeed) === 0) posY += dirY * moveSpeed;
        }
        if (keysDown["s"] || keysDown["S"]) {
          if (mapAt(posX - dirX * moveSpeed, posY) === 0) posX -= dirX * moveSpeed;
          if (mapAt(posX, posY - dirY * moveSpeed) === 0) posY -= dirY * moveSpeed;
        }
        // Rotate left/right
        if (keysDown["ArrowLeft"]) {
          const oldDirX = dirX;
          dirX = dirX * Math.cos(rotSpeed) - dirY * Math.sin(rotSpeed);
          dirY = oldDirX * Math.sin(rotSpeed) + dirY * Math.cos(rotSpeed);
          const oldPlaneX = planeX;
          planeX = planeX * Math.cos(rotSpeed) - planeY * Math.sin(rotSpeed);
          planeY = oldPlaneX * Math.sin(rotSpeed) + planeY * Math.cos(rotSpeed);
        }
        if (keysDown["ArrowRight"]) {
          const oldDirX = dirX;
          dirX = dirX * Math.cos(-rotSpeed) - dirY * Math.sin(-rotSpeed);
          dirY = oldDirX * Math.sin(-rotSpeed) + dirY * Math.cos(-rotSpeed);
          const oldPlaneX = planeX;
          planeX = planeX * Math.cos(-rotSpeed) - planeY * Math.sin(-rotSpeed);
          planeY = oldPlaneX * Math.sin(-rotSpeed) + planeY * Math.cos(-rotSpeed);
        }
      }

      /***** Block Breaking (Mining) *****/
      // When left–clicking, we cast a ray from the center of the screen and try to break the block there.
      canvas.addEventListener("click", function (e) {
        // For simplicity, use center column of the screen.
        const centerX = Math.floor(canvas.width / 2);
        // We perform the raycasting loop just as in renderScene but only for one column.
        const cameraX = 2 * centerX / canvas.width - 1;
        const rayDirX = dirX + planeX * cameraX;
        const rayDirY = dirY + planeY * cameraX;
        let mapX = Math.floor(posX);
        let mapY = Math.floor(posY);
        const deltaDistX = Math.abs(1 / rayDirX);
        const deltaDistY = Math.abs(1 / rayDirY);
        let sideDistX, sideDistY;
        let stepX, stepY;
        if (rayDirX < 0) {
          stepX = -1;
          sideDistX = (posX - mapX) * deltaDistX;
        } else {
          stepX = 1;
          sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }
        if (rayDirY < 0) {
          stepY = -1;
          sideDistY = (posY - mapY) * deltaDistY;
        } else {
          stepY = 1;
          sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }
        let hit = false;
        let side;
        while (!hit) {
          if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
            side = 0;
          } else {
            sideDistY += deltaDistY;
            mapY += stepY;
            side = 1;
          }
          if (mapAt(mapX, mapY) > 0) hit = true;
        }
        // "Break" the block: set it to 0
        setMap(mapX, mapY, 0);
      });

      /***** Block Placement *****/
      // When right–clicking, we place a block (from our inventory) at the center-targeted location, if possible.
      canvas.addEventListener("contextmenu", function (e) {
        e.preventDefault();
        const centerX = Math.floor(canvas.width / 2);
        const cameraX = 2 * centerX / canvas.width - 1;
        const rayDirX = dirX + planeX * cameraX;
        const rayDirY = dirY + planeY * cameraX;
        let mapX = Math.floor(posX);
        let mapY = Math.floor(posY);
        const deltaDistX = Math.abs(1 / rayDirX);
        const deltaDistY = Math.abs(1 / rayDirY);
        let sideDistX, sideDistY;
        let stepX, stepY;
        if (rayDirX < 0) {
          stepX = -1;
          sideDistX = (posX - mapX) * deltaDistX;
        } else {
          stepX = 1;
          sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }
        if (rayDirY < 0) {
          stepY = -1;
          sideDistY = (posY - mapY) * deltaDistY;
        } else {
          stepY = 1;
          sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }
        let hit = false;
        while (!hit) {
          if (sideDistX < sideDistY) {
            sideDistX += deltaDistX;
            mapX += stepX;
          } else {
            sideDistY += deltaDistY;
            mapY += stepY;
          }
          if (mapAt(mapX, mapY) > 0) hit = true;
        }
        // Now, try to place a block in front of the hit wall.
        // We'll choose the block type from the currently selected slot.
        const selItem = inventoryOrder[selectedSlot];
        // Only allow placement if it's one of our placeable block types.
        if (["dirt", "stone", "grass", "wood", "leaves"].includes(selItem)) {
          // Check that target cell is empty and adjacent to a wall.
          if (mapAt(mapX, mapY) === 0) {
            // (For simplicity we don't do a full adjacency check here.)
            setMap(mapX, mapY, selItem === "dirt" ? 1 :
                                  selItem === "stone" ? 2 :
                                  selItem === "grass" ? 3 :
                                  selItem === "wood" ? 4 :
                                  selItem === "leaves" ? 5 : 0);
            if (inventory[selItem] > 0) inventory[selItem]--;
          }
        }
        return false;
      });

      /***** Inventory Display *****/
      const inventoryDiv = document.getElementById("inventory");
      function updateInventoryDisplay() {
        let text = "Inventory: ";
        inventoryOrder.forEach((item, i) => {
          if (i === selectedSlot) text += "[" + item + ":" + (inventory[item] || 0) + "] ";
          else text += item + ":" + (inventory[item] || 0) + " ";
        });
        inventoryDiv.textContent = text;
      }

      /***** Game Loop *****/
      function gameLoop() {
        updatePlayer();
        updateInventoryDisplay();
        renderScene();
        // Simple enemy (slime) update and spawning
        updateEnemies();
        updateSlimeSpawning();
        updateMining();
        requestAnimationFrame(gameLoop);
      }

      /***** Enemy and Slime Code (2.5D) *****/
      const enemies = [];
      function spawnEnemy(x, y) {
        enemies.push({
          x: x, // in map coordinates (float)
          y: y,
          dirX: 0,
          dirY: 1,
          speed: 0.02,
          health: 20,
          type: "slime"
        });
      }
      // Spawn a few initial slimes
      for (let i = 0; i < 3; i++) {
        let sx = Math.floor(Math.random() * (mapWidth - 2)) + 1;
        let sy = Math.floor(Math.random() * (mapHeight - 2)) + 1;
        if (mapAt(sx, sy) === 0) spawnEnemy(sx + 0.5, sy + 0.5);
      }
      function updateEnemies() {
        for (let i = enemies.length - 1; i >= 0; i--) {
          let enemy = enemies[i];
          // Very simple AI: move slowly toward the player if path is clear.
          const dx = posX - enemy.x;
          const dy = posY - enemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0.2) {
            enemy.x += (dx / dist) * enemy.speed;
            enemy.y += (dy / dist) * enemy.speed;
          }
          // Collision with player: reduce player health.
          if (Math.abs(enemy.x - posX) < 0.5 && Math.abs(enemy.y - posY) < 0.5) {
            player.health -= 0.2;
          }
          // If enemy is "killed" (for example, by mining it out – not implemented fully here), drop gel.
          if (enemy.health <= 0) {
            inventory.gel = (inventory.gel || 0) + (Math.floor(Math.random() * 2) + 1);
            enemies.splice(i, 1);
          }
        }
      }
      function updateSlimeSpawning() {
        // Increase slime spawning frequency
        if (enemies.length < 5 && Math.random() < 0.02) {
          let sx = Math.floor(Math.random() * (mapWidth - 2)) + 1;
          let sy = Math.floor(Math.random() * (mapHeight - 2)) + 1;
          if (mapAt(sx, sy) === 0) spawnEnemy(sx + 0.5, sy + 0.5);
        }
      }

      /***** Mining (for enemies) *****/
      // For simplicity, left-clicking breaks blocks (as above) but if you "mine" an enemy by colliding with it (or extended code) you could reduce its health.
      // (Not fully implemented in this minimal demo.)
      function updateMining() {
        // This demo relies on click events to break blocks.
      }

      /***** Start the Game Loop *****/
      gameLoop();
    </script>
  </body>
</html>
