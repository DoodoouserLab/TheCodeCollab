<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ExploreBox v1.4.1</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#141414; }
    canvas { display:block; image-rendering: pixelated; background: #222; }
    /* Inventory/Panel UI for better appearance */
    #game::-webkit-scrollbar { display: none; }
    /* Inventory Modal Styles */
    #extra-inventory-modal {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.7);
      display: none;
      z-index: 11;
      justify-content: center;
      align-items: center;
    }
    #extra-inventory-content {
      background: #232b2b;
      border: 3px solid #ffe066;
      border-radius: 18px;
      min-width: 420px;
      min-height: 300px;
      max-width: 92vw;
      max-height: 80vh;
      overflow: auto;
      box-shadow: 0 10px 48px #000c;
      padding: 22px 28px 16px 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #extra-inventory-content h2 {
      margin: 0 0 18px 0;
      color: #ffe066;
      font-family: "Courier New", monospace;
      font-size: 28px;
      text-align: center;
    }
    .extra-inventory-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 13px;
      width: 100%;
      justify-items: center;
      margin-bottom: 10px;
    }
    .extra-inventory-slot {
      background: #383838;
      border: 2px solid #888;
      border-radius: 9px;
      padding: 8px 6px 3px 6px;
      min-width: 72px;
      min-height: 62px;
      text-align: center;
      color: #FFF;
      font-family: "Courier New", monospace;
      font-size: 15px;
      box-shadow: 0 2px 6px #0004;
      transition: border-color 0.2s;
      position: relative;
    }
    .extra-inventory-slot .qty {
      position: absolute;
      bottom: 3px;
      right: 7px;
      font-size: 14px;
      color: #ffe066;
      font-weight: bold;
      text-shadow: 1px 1px 2px #222, 0 0 2px #222;
    }
    #close-extra-inv {
      color: #ffe066;
      background: #222;
      border: 1px solid #ffe066;
      border-radius: 6px;
      padding: 2px 10px;
      font-size: 17px;
      margin-top: 5px;
      cursor: pointer;
      transition: background 0.18s, color 0.18s;
      font-family: "Courier New", monospace;
    }
    #close-extra-inv:hover {
      background: #ffe066;
      color: #232b2b;
    }
    /* Crafting Search Styles */
    #crafting-search-bar {
      margin-bottom: 15px;
      width: 90%;
      max-width: 350px;
      padding: 7px 10px;
      font-size: 16px;
      border-radius: 7px;
      border: 1.6px solid #ffe066;
      background: #232b2b;
      color: #ffe066;
      outline: none;
      font-family: "Courier New", monospace;
      box-shadow: 0 2px 7px #0003;
    }
    @media (max-width: 500px) {
      #extra-inventory-content {
        min-width: 88vw;
        padding: 7vw 2vw 3vw 2vw;
      }
      .extra-inventory-slot { min-width: 56px; min-height: 48px; font-size: 12px;}
      #extra-inventory-content h2 { font-size: 20px;}
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<!-- Extra Inventory Modal -->
<div id="extra-inventory-modal">
  <div id="extra-inventory-content">
    <h2>Inventory</h2>
    <div class="extra-inventory-grid" id="extra-inventory-grid"></div>
    <button id="close-extra-inv" tabindex="0">Close [E]</button>
  </div>
</div>

<script>
/* ===== Canvas & FPS Meter ===== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

let frames = 0, fps = 0, lastFpsUpdate = performance.now();
function updateFpsMeter() {
  frames++;
  let now = performance.now();
  if (now - lastFpsUpdate >= 500) {
    fps = Math.round(frames * 1000 / (now - lastFpsUpdate));
    frames = 0;
    lastFpsUpdate = now;
  }
}
function drawFpsMeter(ctx) {
  ctx.font = "16px Courier New";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "left";
  ctx.fillText("FPS: " + fps, 12, 24);
}

/* ===== World Generation ===== */
const tileSize = 16;
const worldWidth = 1000, worldHeight = 400;
const blockColors = {
  0: "#87CEEB", // sky
  1: "#ba7a3a", // dirt
  2: "#a7a7a7", // stone
  3: "#3ec14d", // grass
  4: "#ad814b", // wood
  5: "#62e05e", // leaves
  6: "#ffe066", // torch
  7: "#b5b5b5", // iron ore
  8: "#1e90ff", // sapphire ore
  9: "#FFD700", // gold ore
 10: "#a0522d", // copper ore
 11: "#ff7f50", // copper bar
 12: "#f0e68c", // gold bar
 13: "#aaaaff", // sapphire gem
 14: "#d8d8d8", // iron bar
};
const blockEdgeColors = {
  1: "#9f682c", 2: "#8b8b8b", 3: "#2b8c34", 4: "#8c6431", 5: "#3e9045", 6: "#ffd700",
  7: "#888", 8: "#1860a7", 9: "#b89d00", 10: "#8b5a2b", 11: "#c96c43", 12: "#b1af68", 13: "#5e5ecf", 14: "#8b8b8b",
};
const blockDurability = {
  1: 2,  // dirt
  2: 4,  // stone
  3: 1,  // grass
  4: 3,  // wood
  5: 1,  // leaves
  6: 1,  // torch
  7: 5,  // iron ore
  8: 6,  // sapphire ore
  9: 7,  // gold ore
 10: 4   // copper ore
};
const world = [], groundHeights = [];
let currentGround = 50;
for (let x = 0; x < worldWidth; x++) {
  currentGround += Math.floor(Math.random() * 5) - 2;
  currentGround = Math.max(20, Math.min(80, currentGround));
  groundHeights[x] = currentGround;
}
for (let x = 0; x < worldWidth; x++) {
  world[x] = [];
  let ground = groundHeights[x];
  for (let y = 0; y < worldHeight; y++) {
    if (y > ground) {
      let r = Math.random();
      // Ores: deeper = more chance
      if (y > ground + 18 && r < 0.008) world[x][y] = 9; // gold ore
      else if (y > ground + 12 && r < 0.013) world[x][y] = 7; // iron ore
      else if (y > ground + 10 && r < 0.012) world[x][y] = 10; // copper ore
      else if (y > ground + 22 && r < 0.004) world[x][y] = 8; // sapphire ore
      else world[x][y] = (Math.random() < 0.2) ? 1 : 2;
    }
    else if (y == ground) world[x][y] = 3;
    else world[x][y] = 0;
  }
}
// Trees
for (let x = 5; x < worldWidth - 5; x++) {
  for (let y = 0; y < worldHeight; y++) {
    if (world[x][y] === 3 && Math.random() < 0.03) {
      const treeHeight = 3 + Math.floor(Math.random() * 3);
      for (let t = 1; t <= treeHeight; t++) if (y - t >= 0) world[x][y - t] = 4;
      const topY = y - treeHeight;
      for (let dx = -1; dx <= 1; dx++) for (let dy = -1; dy <= 1; dy++)
        if (x + dx >= 0 && x + dx < worldWidth && topY + dy >= 0) {
          if (Math.random() < 0.7) world[x + dx][topY + dy] = 5;
        }
    }
  }
}
// Caves
(function generateCaves() {
  for (let i = 0; i < 30; i++) {
    let startX = Math.floor(Math.random() * worldWidth);
    let startY = groundHeights[startX] + 5 + Math.floor(Math.random() * 20);
    const length = Math.floor(Math.random() * 100) + 50;
    let angle = Math.random() * 2 * Math.PI;
    for (let j = 0; j < length; j++) {
      const cx = Math.floor(startX), cy = Math.floor(startY), radius = Math.floor(Math.random() * 2) + 1;
      for (let ax = -radius; ax <= radius; ax++) for (let ay = -radius; ay <= radius; ay++) {
        const dx = cx + ax, dy = cy + ay;
        if (dx >= 0 && dx < worldWidth && dy >= 0 && dy < worldHeight)
          if (ax * ax + ay * ay <= radius * radius) world[dx][dy] = 0;
      }
      startX += Math.cos(angle); startY += Math.sin(angle); angle += (Math.random() - 0.5) * 0.3;
      if (startX < 0 || startX >= worldWidth || startY < 0 || startY >= worldHeight) break;
    }
  }
})();

function findSurfaceY(x) {
  for (let y = 0; y < worldHeight; y++) if (world[x][y] !== 0) return y - 1;
  return worldHeight - 2;
}
const blockHealth = [];
for (let x = 0; x < worldWidth; x++) {
  blockHealth[x] = [];
  for (let y = 0; y < worldHeight; y++) {
    const b = world[x][y];
    blockHealth[x][y] = (b !== 0 && blockDurability[b] !== undefined) ? blockDurability[b] : 0;
  }
}
function setBlock(x, y, block) {
  if (x < 0 || x >= worldWidth || y < 0 || y >= worldHeight) return;
  world[x][y] = block;
  blockHealth[x][y] = (block !== 0 && blockDurability[block]) ? blockDurability[block] : 0;
}
function getBlock(x, y) {
  if (x < 0 || x >= worldWidth || y < 0 || y >= worldHeight) return 0;
  return world[x][y];
}

/* ===== Lighting System (BRIGHTER) ===== */
const LIGHT_SURFACE_Y = 15;
const TORCH_LIGHT_RADIUS = 6; // 6 blocks
let dynamicLightMap = [];
function resetLightMap() {
  dynamicLightMap = [];
  for (let x = 0; x < worldWidth; x++) {
    dynamicLightMap[x] = [];
    for (let y = 0; y < worldHeight; y++) {
      dynamicLightMap[x][y] = (y < LIGHT_SURFACE_Y) ? 1 : 0.65;
    }
  }
}
function propagateTorchLight() {
  for (let x = 0; x < worldWidth; x++) {
    for (let y = 0; y < worldHeight; y++) {
      if (world[x][y] === 6) {
        for (let dx = -TORCH_LIGHT_RADIUS; dx <= TORCH_LIGHT_RADIUS; dx++) {
          for (let dy = -TORCH_LIGHT_RADIUS; dy <= TORCH_LIGHT_RADIUS; dy++) {
            let tx = x + dx, ty = y + dy;
            if (tx < 0 || tx >= worldWidth || ty < 0 || ty >= worldHeight) continue;
            let dist = Math.sqrt(dx * dx + dy * dy);
            let strength = Math.max(0, 1 - dist / TORCH_LIGHT_RADIUS);
            dynamicLightMap[tx][ty] = Math.max(dynamicLightMap[tx][ty], strength);
          }
        }
      }
    }
  }
}

/* ===== Player ===== */
const mainInventoryOrder = [
  "wood", "stone", "gel", "dirt", "grass", "leaves", "wooden_pickaxe", "wooden_sword", "torch"
];
// All other items go in extra inventory
const extraInventoryOrder = [
  "copper_ore", "iron_ore", "gold_ore", "sapphire_ore",
  "copper_bar", "iron_bar", "gold_bar", "sapphire_gem",
  "iron_pickaxe", "iron_sword", "gold_pickaxe", "sapphire_staff"
];
const player = {
  x: 50 * tileSize,
  y: findSurfaceY(50) * tileSize,
  width: tileSize,
  height: tileSize * 1.8,
  vx: 0, vy: 0,
  speed: 4,
  jumpStrength: 12,
  grounded: false,
  health: 100,
  hunger: 100,
  maxHunger: 100,
  inventory: {
    wood:20,stone:20,gel:10,dirt:0,grass:0,leaves:0,wooden_pickaxe:0,wooden_sword:0,torch:10,
    copper_ore:0, iron_ore:0, gold_ore:0, sapphire_ore:0,
    copper_bar:0, iron_bar:0, gold_bar:0, sapphire_gem:0,
    iron_pickaxe:0, iron_sword:0, gold_pickaxe:0, sapphire_staff:0
  },
  xp: 0, xpToNext: 20,
  selectedSlot: 0
};
function handlePlayerDeath() {
  for (let key in player.inventory) {
    let amt = player.inventory[key] || 0;
    if (amt > 0) {
      droppedItems.push({x: Math.floor(player.x / tileSize), y: Math.floor(player.y / tileSize), key, amount: amt});
      player.inventory[key] = 0;
    }
  }
}
function respawnPlayer() {
  isDead = false;
  player.health = 100;
  player.hunger = player.maxHunger;
  player.x = 50 * tileSize;
  player.y = findSurfaceY(50) * tileSize;
}

/* ===== Hunger System ===== */
let hungerTick = 0;
function updateHunger() {
  if (isDead || craftingMenuActive) return;
  hungerTick++;
  if (hungerTick > 60) {
    player.hunger -= 1;
    hungerTick = 0;
    if (player.hunger < 0) player.hunger = 0;
    // Lose health if hunger is 0
    if (player.hunger === 0) {
      player.health -= 1.2; // Increased for effect, adjust as you wish
      if (player.health <= 0 && !isDead) {
        isDead = true;
        handlePlayerDeath();
      }
    }
  }
  // Healing if hunger > 80 and not full health
  if (player.health < 100 && player.hunger > 80) {
    player.health += 0.15;
    if (player.health > 100) player.health = 100;
  }
}
function tryEatGel() {
  if (player.inventory.gel > 0 && player.hunger < player.maxHunger) {
    player.inventory.gel--;
    player.hunger += 30;
    if (player.hunger > player.maxHunger) player.hunger = player.maxHunger;
  }
}

/* ====== Enemies (Slimes) ====== */
const enemies = [];
const MAX_ENEMIES = 3;
const ENEMY_VISIBLE_RADIUS = 900;
const SLIME_SIGHT_DISTANCE = tileSize * 17.75;

function spawnEnemy(x, y) {
  let tileX = Math.floor(x / tileSize), tileY = Math.floor(y / tileSize);
  while (tileY > 0 && getBlock(tileX, tileY) !== 0) tileY--;
  enemies.push({
    x: tileX * tileSize,
    y: tileY * tileSize,
    width: tileSize,
    height: tileSize,
    vx: 0, vy: 0, speed: 0.3,
    grounded: false,
    health: 20,
    type: "slime",
    bounceCooldown: 0
  });
}

// Initial spawn
for (let i = 0; i < 3; i++) {
  let ex = Math.floor(Math.random() * (worldWidth - 20)) + 10, ey = findSurfaceY(ex);
  spawnEnemy(ex * tileSize, ey * tileSize);
}

function updateEnemies() {
  for (let i = enemies.length - 1; i >= 0; i--) {
    let enemy = enemies[i];
    let centerX = enemy.x + enemy.width / 2, centerY = enemy.y + enemy.height / 2;
    let dx = centerX - (player.x + player.width / 2), dy = centerY - (player.y + player.height / 2);
    if (Math.abs(dx) > ENEMY_VISIBLE_RADIUS || Math.abs(dy) > ENEMY_VISIBLE_RADIUS) continue;

    enemy.bounceCooldown--;
    let pdx = player.x - enemy.x, pdist = Math.abs(pdx);
    if (pdist < SLIME_SIGHT_DISTANCE) {
      if (pdx > 8) enemy.vx = Math.min(enemy.vx + 0.13, enemy.speed);
      else if (pdx < -8) enemy.vx = Math.max(enemy.vx - 0.13, -enemy.speed);
      else enemy.vx *= 0.85;
    } else {
      if (Math.random() < 0.02) enemy.vx = (Math.random() - 0.5) * enemy.speed * 2;
      else enemy.vx *= 0.98;
    }
    if (enemy.grounded && enemy.bounceCooldown <= 0) {
      enemy.vy = -4.5 - Math.random() * 1.3;
      enemy.bounceCooldown = 50 + Math.floor(Math.random() * 30);
    }
    if (enemy.grounded) enemy.vx *= 0.80;

    updateEntityPhysics(enemy);

    if (checkCollision(enemy, player) && !isDead) {
      player.health -= 0.4;
      if (player.health <= 0 && !isDead) { isDead = true; handlePlayerDeath(); }
    }
    if (enemy.health <= 0) {
      droppedItems.push({
        x: Math.floor(enemy.x / tileSize),
        y: Math.floor(enemy.y / tileSize),
        key: "gel",
        amount: 1
      });
      enemies.splice(i, 1);
    }
  }
}

// Slime spawn prevention: No spawn in any torch radius
function isInTorchLightRadius(x, y) {
  for (let tx = Math.max(0, x - TORCH_LIGHT_RADIUS); tx <= Math.min(worldWidth - 1, x + TORCH_LIGHT_RADIUS); tx++) {
    for (let ty = Math.max(0, y - TORCH_LIGHT_RADIUS); ty <= Math.min(worldHeight - 1, y + TORCH_LIGHT_RADIUS); ty++) {
      if (world[tx][ty] === 6) {
        const dist = Math.sqrt((tx - x) * (tx - x) + (ty - y) * (ty - y));
        if (dist <= TORCH_LIGHT_RADIUS) return true;
      }
    }
  }
  return false;
}

function updateSlimeSpawning() {
  let onscreen = 0;
  for (let e of enemies) {
    let centerX = e.x + e.width / 2, centerY = e.y + e.height / 2;
    let dx = centerX - (player.x + player.width / 2), dy = centerY - (player.y + player.height / 2);
    if (Math.abs(dx) < ENEMY_VISIBLE_RADIUS && Math.abs(dy) < ENEMY_VISIBLE_RADIUS) onscreen++;
  }
  if (onscreen < MAX_ENEMIES && Math.random() < 0.01) {
    let attempts = 0, found = false, spawnX, spawnY;
    while (attempts < 16 && !found) {
      spawnX = Math.floor(player.x / tileSize) + Math.floor((Math.random() - 0.5) * 30);
      spawnX = Math.max(3, Math.min(worldWidth - 3, spawnX));
      let surfaceY = groundHeights[spawnX];
      spawnY = surfaceY + Math.floor(Math.random() * 35);
      spawnY = Math.min(worldHeight - 10, spawnY);
      // Ensure not in torch radius
      if (!isInTorchLightRadius(spawnX, spawnY) && dynamicLightMap[spawnX] && dynamicLightMap[spawnX][spawnY] < 0.85) found = true;
      attempts++;
    }
    if (found) spawnEnemy(spawnX * tileSize, spawnY * tileSize);
    else if (Math.random() < 0.5) {
      let ex = Math.floor(player.x / tileSize) + Math.floor((Math.random() - 0.5) * 40);
      ex = Math.max(3, Math.min(worldWidth - 3, ex));
      let ey = findSurfaceY(ex);
      if (!isInTorchLightRadius(ex, ey)) spawnEnemy(ex * tileSize, ey * tileSize);
    }
  }
}

/* ===== Physics ===== */
function checkCollision(a, b) {
  return (a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y);
}
function isSolid(block) { return block !== 0 && block !== 11 && block !== 12 && block !== 13 && block !== 14; } // bars/gems not solid
function isColliding(entity) {
  const leftTile = Math.floor(entity.x / tileSize),
        rightTile = Math.floor((entity.x + entity.width - 1) / tileSize),
        topTile = Math.floor(entity.y / tileSize),
        bottomTile = Math.floor((entity.y + entity.height - 1) / tileSize);
  for (let x = leftTile; x <= rightTile; x++)
    for (let y = topTile; y <= bottomTile; y++)
      if (isSolid(getBlock(x, y))) return true;
  return false;
}
const GRAVITY = 0.4;
const FRICTION_GROUND = 0.8;
const FRICTION_AIR = 0.96;

function updateEntityPhysics(entity) {
  entity.x += entity.vx;
  if (isColliding(entity)) { entity.x -= entity.vx; entity.vx = 0; }
  entity.vy += GRAVITY;
  entity.y += entity.vy;
  entity.grounded = false;
  if (isColliding(entity)) {
    entity.y -= entity.vy;
    if (entity.vy > 0) entity.grounded = true;
    entity.vy = 0;
  }
  if (entity.grounded) entity.vx *= FRICTION_GROUND;
  else entity.vx *= FRICTION_AIR;
}

/* ===== Mining ===== */
let isMining = false, currentMiningTarget = null, lastMousePos = { x: 0, y: 0 };
function getMiningMultiplier() {
  // Pickaxe upgrades: wooden < iron < gold
  if (player.inventory.gold_pickaxe > 0) return 3.5;
  if (player.inventory.iron_pickaxe > 0) return 2.5;
  if (player.inventory.wooden_pickaxe > 0) return 2;
  return 0.5;
}
const miningDamage = 0.1;
function updateMining() {
  if (!isMining || isDead) return;
  const cameraX = player.x - canvas.width / 2 + player.width / 2,
        cameraY = player.y - canvas.height / 2 + player.height / 2;
  let targetX = Math.floor((lastMousePos.x + cameraX) / tileSize),
      targetY = Math.floor((lastMousePos.y + cameraY) / tileSize);
  if (!currentMiningTarget || currentMiningTarget.x !== targetX || currentMiningTarget.y !== targetY)
    currentMiningTarget = { x: targetX, y: targetY };
  if (targetX < 0 || targetX >= worldWidth || targetY < 0 || targetY >= worldHeight) return;
  let block = world[targetX][targetY];
  if (block === 0 || blockDurability[block] === undefined) { currentMiningTarget = null; return; }
  const blockCenterX = (targetX + 0.5) * tileSize,
        blockCenterY = (targetY + 0.5) * tileSize,
        playerCenterX = player.x + player.width / 2,
        playerCenterY = player.y + player.height / 2;
  const dx = blockCenterX - playerCenterX, dy = blockCenterY - playerCenterY, distance = Math.sqrt(dx * dx + dy * dy);
  if (distance > 90) return;
  const effectiveDamage = miningDamage * getMiningMultiplier();
  blockHealth[targetX][targetY] -= effectiveDamage;
  if (blockHealth[targetX][targetY] <= 0) {
    switch (block) {
      case 1: player.inventory.dirt++; break;
      case 2: player.inventory.stone++; break;
      case 3: player.inventory.grass++; break;
      case 4: player.inventory.wood++; break;
      case 5: player.inventory.leaves++; break;
      case 7: player.inventory.iron_ore++; break;
      case 8: player.inventory.sapphire_ore++; break;
      case 9: player.inventory.gold_ore++; break;
      case 10: player.inventory.copper_ore++; break;
    }
    setBlock(targetX, targetY, 0); currentMiningTarget = null;
  }
}

/* ===== Block Placement ===== */
const placeableMapping = {
  "dirt": 1, "stone": 2, "grass": 3, "wood": 4, "leaves": 5, "torch": 6,
  "iron_ore": 7, "sapphire_ore": 8, "gold_ore": 9, "copper_ore": 10,
  "copper_bar": 11, "gold_bar": 12, "sapphire_gem": 13, "iron_bar": 14
};
function canPlaceBlockAt(x, y) {
  if (getBlock(x, y) !== 0) return false;
  if (y === worldHeight - 1) return true;
  const deltas = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
  for (let d of deltas) if (getBlock(x + d.dx, y + d.dy) !== 0) return true;
  return false;
}
function handleBlockPlacement(event) {
  if (isDead) return;
  const rect = canvas.getBoundingClientRect();
  let clientX = event.clientX || event.touches?.[0]?.clientX,
      clientY = event.clientY || event.touches?.[0]?.clientY;
  if (clientX == null || clientY == null) return;
  const mx = clientX - rect.left, my = clientY - rect.top,
        cameraX = player.x - canvas.width / 2 + player.width / 2,
        cameraY = player.y - canvas.height / 2 + player.height / 2;
  let targetX = Math.floor((mx + cameraX) / tileSize),
      targetY = Math.floor((my + cameraY) / tileSize);
  const selectedItem = mainInventoryOrder[player.selectedSlot];
  if (!(selectedItem in placeableMapping)) return;
  if (player.inventory[selectedItem] <= 0) return;
  if (!canPlaceBlockAt(targetX, targetY)) return;
  setBlock(targetX, targetY, placeableMapping[selectedItem]);
  player.inventory[selectedItem]--;
  resetLightMap();
  propagateTorchLight();
}
canvas.addEventListener("contextmenu", function(e) { e.preventDefault(); handleBlockPlacement(e); return false; });

/* ===== Crafting ===== */
/* Terraria-inspired recipes */
const recipes = [
  { name: "Torch", ingredients: { wood: 1, gel: 1 }, result: { key: "torch", amount: 3 }},
  { name: "Wooden Pickaxe", ingredients: { wood: 10, stone: 3 }, result: { key: "wooden_pickaxe", amount: 1 }},
  { name: "Wooden Sword", ingredients: { wood: 7 }, result: { key: "wooden_sword", amount: 1 }},
  // Smelting
  { name: "Copper Bar", ingredients: { copper_ore: 3, wood: 1 }, result: { key: "copper_bar", amount: 1 }},
  { name: "Iron Bar", ingredients: { iron_ore: 3, wood: 1 }, result: { key: "iron_bar", amount: 1 }},
  { name: "Gold Bar", ingredients: { gold_ore: 3, wood: 1 }, result: { key: "gold_bar", amount: 1 }},
  { name: "Sapphire Gem", ingredients: { sapphire_ore: 1 }, result: { key: "sapphire_gem", amount: 1 }},
  // Tools/Weapons
  { name: "Iron Pickaxe", ingredients: { iron_bar: 5, wood: 2 }, result: { key: "iron_pickaxe", amount: 1 }},
  { name: "Iron Sword", ingredients: { iron_bar: 6, wood: 2 }, result: { key: "iron_sword", amount: 1 }},
  { name: "Gold Pickaxe", ingredients: { gold_bar: 7, wood: 2 }, result: { key: "gold_pickaxe", amount: 1 }},
  { name: "Sapphire Staff", ingredients: { sapphire_gem: 5, wood: 3 }, result: { key: "sapphire_staff", amount: 1 }},
];
let craftingMenuActive = false, recipeMenuBoxes = [];
let craftingSearchQuery = ""; // for search bar

function canCraft(recipe) {
  for (let ingr in recipe.ingredients)
    if (!player.inventory[ingr] || player.inventory[ingr] < recipe.ingredients[ingr]) return false;
  return true;
}
function craftItem(recipe) {
  if (canCraft(recipe)) {
    for (let ingr in recipe.ingredients) player.inventory[ingr] -= recipe.ingredients[ingr];
    const resKey = recipe.result.key;
    player.inventory[resKey] = (player.inventory[resKey] || 0) + recipe.result.amount;
  }
}
function handleCraftingMenuClick(e) {
  const rect = canvas.getBoundingClientRect();
  let mx = e.clientX - rect.left, my = e.clientY - rect.top;
  for (let box of recipeMenuBoxes)
    if (mx >= box.x && mx <= box.x + box.width && my >= box.y && my <= box.y + box.height) craftItem(box.recipe);
}

/* ===== Input ===== */
const keys = {};
window.addEventListener("keydown", e => {
  // Inventory modal toggle - "e"
  if ((e.key === "e" || e.key === "E") && !craftingMenuActive && !isDead) {
    toggleExtraInventory();
    e.preventDefault();
    return;
  }
  // Crafting menu toggle - "c"
  if (e.key === "c" || e.key === "C") craftingMenuActive = !craftingMenuActive;
  // Main inventory hotbar selection
  if (!isNaN(e.key) && e.key !== "0") {
    const slot = parseInt(e.key) - 1;
    if (slot < mainInventoryOrder.length) player.selectedSlot = slot;
  }
  // Only allow movement/attack if not in modal or crafting
  if (!craftingMenuActive && !extraInventoryOpen) keys[e.key] = true;
  // Move food-eating to F (or f)
  if (e.key === "f" || e.key === "F") tryEatGel();
});
window.addEventListener("keyup", e => {
  if (!craftingMenuActive && !extraInventoryOpen) keys[e.key] = false;
});
canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  lastMousePos.x = e.clientX - rect.left;
  lastMousePos.y = e.clientY - rect.top;
});
canvas.addEventListener("mousedown", e => {
  if (isDead) { respawnPlayer(); return; }
  // Don't allow mining or attack when inventory modal open
  if (extraInventoryOpen) return;
  if (craftingMenuActive) { handleCraftingMenuClick(e); }
  else { isMining = true; const rect = canvas.getBoundingClientRect(); lastMousePos.x = e.clientX - rect.left; lastMousePos.y = e.clientY - rect.top; tryAttackEnemy(); }
});
canvas.addEventListener("mouseup", e => { if (!craftingMenuActive && !extraInventoryOpen) { isMining = false; currentMiningTarget = null; }});
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  if (isDead) { respawnPlayer(); return; }
  if (extraInventoryOpen) return;
  const touch = e.touches[0], rect = canvas.getBoundingClientRect();
  lastMousePos.x = touch.clientX - rect.left; lastMousePos.y = touch.clientY - rect.top;
  if (craftingMenuActive) { handleCraftingMenuClick(touch); } else isMining = true;
}, { passive: false });
canvas.addEventListener("touchend", e => {
  e.preventDefault();
  if (!craftingMenuActive && !extraInventoryOpen) { isMining = false; currentMiningTarget = null; }
}, { passive: false });

/* ===== Combat ===== */
function tryAttackEnemy() {
  const selectedItem = mainInventoryOrder[player.selectedSlot];
  // New: allow iron/gold sword and sapphire staff
  const swords = ["wooden_sword", "iron_sword", "sapphire_staff"];
  if (!swords.includes(selectedItem) || player.inventory[selectedItem] <= 0) return;
  const playerCenterX = player.x + player.width / 2, playerCenterY = player.y + player.height / 2;
  for (let i = enemies.length - 1; i >= 0; i--) {
    const enemy = enemies[i], enemyCenterX = enemy.x + enemy.width / 2, enemyCenterY = enemy.y + enemy.height / 2,
          dx = enemyCenterX - playerCenterX, dy = enemyCenterY - playerCenterY, distance = Math.sqrt(dx * dx + dy * dy);
    let damage = 10;
    if (selectedItem === "iron_sword") damage = 17;
    if (selectedItem === "sapphire_staff") damage = 22;
    if (distance < 50) { enemy.health -= damage; if (enemy.health <= 0) {
      // Drop gel when killed (handled in updateEnemies)
    } break; }
  }
}

/* ===== UI ===== */
function drawIcon(itemKey, x, y, size) {
  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,0.3)";
  ctx.shadowBlur = 2;
  switch (itemKey) {
    case "dirt":
      ctx.fillStyle = "#ba7a3a"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      break;
    case "stone":
      ctx.fillStyle = "#a7a7a7"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      break;
    case "grass":
      ctx.fillStyle = "#3ec14d"; roundRect(ctx, x, y, size, size * 0.4, 5); ctx.fill();
      ctx.fillStyle = "#ba7a3a"; roundRect(ctx, x, y + size * 0.4, size, size * 0.6, 5); ctx.fill();
      break;
    case "wood":
      ctx.fillStyle = "#ad814b"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      break;
    case "leaves":
      ctx.fillStyle = "#62e05e"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      break;
    case "gel":
      ctx.fillStyle = "#7FFFD4"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      break;
    case "torch":
      ctx.fillStyle = "#ffe066"; roundRect(ctx, x + size*0.35, y + size*0.2, size*0.3, size*0.6, 4); ctx.fill();
      ctx.fillStyle = "#dca700"; roundRect(ctx, x + size*0.42, y + size*0.18, size*0.16, size*0.18, 2); ctx.fill();
      break;
    case "wooden_pickaxe":
      ctx.fillStyle = "#ad814b"; roundRect(ctx, x + size * 0.35, y + size * 0.3, size * 0.1, size * 0.5, 2); ctx.fill();
      ctx.fillStyle = "#a7a7a7"; roundRect(ctx, x + size * 0.2, y + size * 0.2, size * 0.4, size * 0.12, 2); ctx.fill();
      break;
    case "wooden_sword":
      ctx.fillStyle = "#a7a7a7"; roundRect(ctx, x + size * 0.45, y + size * 0.1, size * 0.1, size * 0.6, 2); ctx.fill();
      ctx.fillStyle = "#ad814b"; roundRect(ctx, x + size * 0.4, y + size * 0.7, size * 0.2, size * 0.12, 2); ctx.fill();
      break;
    case "copper_ore":
      ctx.fillStyle = "#a0522d"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      ctx.strokeStyle = "#ff7f50"; ctx.lineWidth = 2;
      roundRect(ctx, x+2, y+2, size-4, size-4, 5); ctx.stroke();
      break;
    case "iron_ore":
      ctx.fillStyle = "#b5b5b5"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      ctx.strokeStyle = "#888"; ctx.lineWidth = 2;
      roundRect(ctx, x+2, y+2, size-4, size-4, 5); ctx.stroke();
      break;
    case "gold_ore":
      ctx.fillStyle = "#FFD700"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      ctx.strokeStyle = "#b89d00"; ctx.lineWidth = 2;
      roundRect(ctx, x+2, y+2, size-4, size-4, 5); ctx.stroke();
      break;
    case "sapphire_ore":
      ctx.fillStyle = "#1e90ff"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
      ctx.strokeStyle = "#1860a7"; ctx.lineWidth = 2;
      roundRect(ctx, x+2, y+2, size-4, size-4, 5); ctx.stroke();
      break;
    case "copper_bar":
      ctx.fillStyle = "#ff7f50"; roundRect(ctx, x, y+size*0.4, size, size*0.4, 4); ctx.fill();
      ctx.strokeStyle = "#a0522d"; ctx.lineWidth = 1.5; ctx.strokeRect(x, y+size*0.4, size, size*0.4);
      break;
    case "iron_bar":
      ctx.fillStyle = "#d8d8d8"; roundRect(ctx, x, y+size*0.4, size, size*0.4, 4); ctx.fill();
      ctx.strokeStyle = "#888"; ctx.lineWidth = 1.5; ctx.strokeRect(x, y+size*0.4, size, size*0.4);
      break;
    case "gold_bar":
      ctx.fillStyle = "#FFD700"; roundRect(ctx, x, y+size*0.4, size, size*0.4, 4); ctx.fill();
      ctx.strokeStyle = "#b89d00"; ctx.lineWidth = 1.5; ctx.strokeRect(x, y+size*0.4, size, size*0.4);
      break;
    case "sapphire_gem":
      ctx.fillStyle = "#aaaaff"; ctx.beginPath();
      ctx.moveTo(x+size/2, y);
      ctx.lineTo(x+size, y+size/2);
      ctx.lineTo(x+size/2, y+size);
      ctx.lineTo(x, y+size/2);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = "#5e5ecf"; ctx.lineWidth = 2; ctx.stroke();
      break;
    case "iron_pickaxe":
      ctx.fillStyle = "#d8d8d8"; roundRect(ctx, x + size * 0.35, y + size * 0.3, size * 0.1, size * 0.5, 2); ctx.fill();
      ctx.fillStyle = "#888"; roundRect(ctx, x + size * 0.2, y + size * 0.2, size * 0.4, size * 0.12, 2); ctx.fill();
      break;
    case "iron_sword":
      ctx.fillStyle = "#d8d8d8"; roundRect(ctx, x + size * 0.45, y + size * 0.1, size * 0.1, size * 0.6, 2); ctx.fill();
      ctx.fillStyle = "#888"; roundRect(ctx, x + size * 0.4, y + size * 0.7, size * 0.2, size * 0.12, 2); ctx.fill();
      break;
    case "gold_pickaxe":
      ctx.fillStyle = "#FFD700"; roundRect(ctx, x + size * 0.35, y + size * 0.3, size * 0.1, size * 0.5, 2); ctx.fill();
      ctx.fillStyle = "#b89d00"; roundRect(ctx, x + size * 0.2, y + size * 0.2, size * 0.4, size * 0.12, 2); ctx.fill();
      break;
    case "sapphire_staff":
      ctx.fillStyle = "#aaaaff"; roundRect(ctx, x + size * 0.47, y + size * 0.18, size * 0.07, size * 0.6, 2); ctx.fill();
      ctx.fillStyle = "#5e5ecf"; ctx.beginPath(); ctx.arc(x + size * 0.5, y + size * 0.15, size * 0.13, 0, Math.PI * 2); ctx.fill();
      break;
    default: ctx.fillStyle = "#FFF"; roundRect(ctx, x, y, size, size, 5); ctx.fill();
  }
  ctx.restore();
}
function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
}
function drawInventory() {
  const invSize = 50, gap = 4, totalWidth = mainInventoryOrder.length * (invSize + gap) - gap;
  const startX = (canvas.width - totalWidth) / 2, y = canvas.height - invSize - 10;
  for (let i = 0; i < mainInventoryOrder.length; i++) {
    const item = mainInventoryOrder[i], x = startX + i * (invSize + gap);
    ctx.save();
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 10;
    ctx.fillStyle = "#232b2b";
    roundRect(ctx, x, y, invSize, invSize, 10);
    ctx.fill();
    if (i === player.selectedSlot) {
      ctx.strokeStyle = "#ffff5e";
      ctx.lineWidth = 4;
    } else {
      ctx.strokeStyle = "#AAAAAA";
      ctx.lineWidth = 2;
    }
    roundRect(ctx, x, y, invSize, invSize, 10);
    ctx.stroke();
    ctx.restore();
    drawIcon(item, x + 10, y + 10, invSize - 20);
    ctx.fillStyle = "#FFF";
    ctx.font = "bold 13px Courier New";
    ctx.textAlign = "right";
    ctx.fillText(player.inventory[item] || 0, x + invSize - 4, y + invSize - 6);
  }
}
function drawCraftingMenu() {
  ctx.save();
  ctx.shadowColor = "#000";
  ctx.shadowBlur = 30;
  ctx.fillStyle = "rgba(30,20,10,0.92)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  const panelWidth = canvas.width * 0.8, panelHeight = canvas.height * 0.6;
  const panelX = (canvas.width - panelWidth) / 2, panelY = (canvas.height - panelHeight) / 2;
  ctx.fillStyle = "#473622";
  roundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20);
  ctx.fill();
  ctx.strokeStyle = "#ffe066";
  ctx.lineWidth = 5;
  roundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20);
  ctx.stroke();
  ctx.font = "26px Courier New";
  ctx.textAlign = "center"; ctx.fillStyle = "#FFF";
  ctx.fillText("Crafting Station", canvas.width / 2, panelY + 40);
  ctx.font = "16px Courier New";
  ctx.fillText("Click a recipe box to craft. Press 'C' to exit.", canvas.width / 2, panelY + 70);

  // Draw search bar
  const searchBarX = canvas.width / 2 - 160, searchBarY = panelY + 80, searchBarW = 320, searchBarH = 28;
  ctx.save();
  ctx.fillStyle = "#232b2b";
  roundRect(ctx, searchBarX, searchBarY, searchBarW, searchBarH, 7); ctx.fill();
  ctx.strokeStyle = "#ffe066"; ctx.lineWidth = 2;
  roundRect(ctx, searchBarX, searchBarY, searchBarW, searchBarH, 7); ctx.stroke();
  ctx.font = "15px Courier New"; ctx.fillStyle = "#ffe066"; ctx.textAlign = "left";
  ctx.fillText(craftingSearchQuery ? craftingSearchQuery : "Search recipes...", searchBarX + 10, searchBarY + 20);
  ctx.restore();

  // Detect click in search bar for focusing search
  craftingSearchBarClickableRect = {x: searchBarX, y: searchBarY, width: searchBarW, height: searchBarH};

  // Draw recipes (filtered)
  let filteredRecipes = recipes.filter(r =>
    r.name.toLowerCase().includes(craftingSearchQuery.toLowerCase()) ||
    Object.keys(r.ingredients).some(ingr => ingr.replace(/_/g," ").toLowerCase().includes(craftingSearchQuery.toLowerCase()))
  );
  const recipeBoxWidth = panelWidth * 0.9, recipeBoxHeight = 60, gap = 15;
  recipeMenuBoxes = []; ctx.textAlign = "left";
  for (let i = 0; i < filteredRecipes.length; i++) {
    const boxX = panelX + (panelWidth - recipeBoxWidth) / 2, boxY = panelY + 120 + i * (recipeBoxHeight + gap);
    ctx.fillStyle = canCraft(filteredRecipes[i]) ? "#8fd14f" : "#555";
    roundRect(ctx, boxX, boxY, recipeBoxWidth, recipeBoxHeight, 12); ctx.fill();
    ctx.strokeStyle = "#FFF"; ctx.lineWidth = 2;
    roundRect(ctx, boxX, boxY, recipeBoxWidth, recipeBoxHeight, 12); ctx.stroke();
    ctx.fillStyle = "#FFF"; ctx.font = "16px Courier New";
    ctx.fillText(filteredRecipes[i].name, boxX + 10, boxY + 20);
    let ingredText = "Requires: ";
    for (let ingr in filteredRecipes[i].ingredients) ingredText += ingr.replace(/_/, " ") + " x" + filteredRecipes[i].ingredients[ingr] + "  ";
    ctx.font = "14px Courier New";
    ctx.fillText(ingredText, boxX + 10, boxY + 40);
    recipeMenuBoxes.push({recipe: filteredRecipes[i], x: boxX, y: boxY, width: recipeBoxWidth, height: recipeBoxHeight});
  }

  ctx.restore();
}

let craftingSearchBarClickableRect = null;
let craftingSearchFocused = false;
window.addEventListener("mousedown", function(e) {
  if (craftingMenuActive && craftingSearchBarClickableRect) {
    const rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left, my = e.clientY - rect.top;
    let b = craftingSearchBarClickableRect;
    if (mx >= b.x && mx <= b.x + b.width && my >= b.y && my <= b.y + b.height) {
      craftingSearchFocused = true;
      e.preventDefault();
    } else {
      craftingSearchFocused = false;
    }
  }
});
window.addEventListener("keydown", function(e) {
  if (craftingMenuActive && craftingSearchFocused) {
    if (e.key.length === 1 && craftingSearchQuery.length < 32) {
      craftingSearchQuery += e.key;
    } else if (e.key === "Backspace") {
      craftingSearchQuery = craftingSearchQuery.slice(0, -1);
    } else if (e.key === "Escape") {
      craftingSearchFocused = false;
    }
    e.preventDefault();
    return false;
  }
  // Clear search on crafting menu close
  if ((e.key === "c" || e.key === "C") && craftingMenuActive === false) {
    craftingSearchQuery = "";
    craftingSearchFocused = false;
  }
});

/* ===== Extra Inventory Modal ===== */
let extraInventoryOpen = false;
function toggleExtraInventory(forceState) {
  const modal = document.getElementById("extra-inventory-modal");
  if (typeof forceState === "boolean") extraInventoryOpen = forceState;
  else extraInventoryOpen = !extraInventoryOpen;
  if (extraInventoryOpen) {
    renderExtraInventory();
    modal.style.display = "flex";
    setTimeout(() => {
      document.getElementById("close-extra-inv").focus();
    }, 16);
  } else {
    modal.style.display = "none";
  }
  // Prevent input if modal is open
}
function renderExtraInventory() {
  const grid = document.getElementById("extra-inventory-grid");
  grid.innerHTML = "";
  extraInventoryOrder.forEach(item => {
    const amt = player.inventory[item] || 0;
    const slot = document.createElement("div");
    slot.className = "extra-inventory-slot";
    // Canvas for icon
    const iconCanvas = document.createElement("canvas");
    iconCanvas.width = 32;
    iconCanvas.height = 32;
    const iconCtx = iconCanvas.getContext("2d");
    drawIconToContext(item, iconCtx, 0, 0, 28);
    slot.appendChild(iconCanvas);
    // Name
    const label = document.createElement("div");
    label.style.fontSize = "12px";
    label.style.color = "#ffe066";
    label.style.marginTop = "-1px";
    label.style.marginBottom = "1px";
    label.textContent = item.replace(/_/g, " ");
    slot.appendChild(label);
    // Qty
    const qty = document.createElement("span");
    qty.className = "qty";
    qty.textContent = amt;
    slot.appendChild(qty);

    grid.appendChild(slot);
  });
}
function drawIconToContext(itemKey, iconCtx, x, y, size) {
  // Same as drawIcon but for any 2D context
  iconCtx.save();
  iconCtx.shadowColor = "rgba(0,0,0,0.3)";
  iconCtx.shadowBlur = 2;
  switch (itemKey) {
    case "dirt":
      iconCtx.fillStyle = "#ba7a3a"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      break;
    case "stone":
      iconCtx.fillStyle = "#a7a7a7"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      break;
    case "grass":
      iconCtx.fillStyle = "#3ec14d"; roundRect(iconCtx, x, y, size, size * 0.4, 5); iconCtx.fill();
      iconCtx.fillStyle = "#ba7a3a"; roundRect(iconCtx, x, y + size * 0.4, size, size * 0.6, 5); iconCtx.fill();
      break;
    case "wood":
      iconCtx.fillStyle = "#ad814b"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      break;
    case "leaves":
      iconCtx.fillStyle = "#62e05e"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      break;
    case "gel":
      iconCtx.fillStyle = "#7FFFD4"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      break;
    case "torch":
      iconCtx.fillStyle = "#ffe066"; roundRect(iconCtx, x + size*0.35, y + size*0.2, size*0.3, size*0.6, 4); iconCtx.fill();
      iconCtx.fillStyle = "#dca700"; roundRect(iconCtx, x + size*0.42, y + size*0.18, size*0.16, size*0.18, 2); iconCtx.fill();
      break;
    case "wooden_pickaxe":
      iconCtx.fillStyle = "#ad814b"; roundRect(iconCtx, x + size * 0.35, y + size * 0.3, size * 0.1, size * 0.5, 2); iconCtx.fill();
      iconCtx.fillStyle = "#a7a7a7"; roundRect(iconCtx, x + size * 0.2, y + size * 0.2, size * 0.4, size * 0.12, 2); iconCtx.fill();
      break;
    case "wooden_sword":
      iconCtx.fillStyle = "#a7a7a7"; roundRect(iconCtx, x + size * 0.45, y + size * 0.1, size * 0.1, size * 0.6, 2); iconCtx.fill();
      iconCtx.fillStyle = "#ad814b"; roundRect(iconCtx, x + size * 0.4, y + size * 0.7, size * 0.2, size * 0.12, 2); iconCtx.fill();
      break;
    case "copper_ore":
      iconCtx.fillStyle = "#a0522d"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      iconCtx.strokeStyle = "#ff7f50"; iconCtx.lineWidth = 2;
      roundRect(iconCtx, x+2, y+2, size-4, size-4, 5); iconCtx.stroke();
      break;
    case "iron_ore":
      iconCtx.fillStyle = "#b5b5b5"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      iconCtx.strokeStyle = "#888"; iconCtx.lineWidth = 2;
      roundRect(iconCtx, x+2, y+2, size-4, size-4, 5); iconCtx.stroke();
      break;
    case "gold_ore":
      iconCtx.fillStyle = "#FFD700"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      iconCtx.strokeStyle = "#b89d00"; iconCtx.lineWidth = 2;
      roundRect(iconCtx, x+2, y+2, size-4, size-4, 5); iconCtx.stroke();
      break;
    case "sapphire_ore":
      iconCtx.fillStyle = "#1e90ff"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
      iconCtx.strokeStyle = "#1860a7"; iconCtx.lineWidth = 2;
      roundRect(iconCtx, x+2, y+2, size-4, size-4, 5); iconCtx.stroke();
      break;
    case "copper_bar":
      iconCtx.fillStyle = "#ff7f50"; roundRect(iconCtx, x, y+size*0.4, size, size*0.4, 4); iconCtx.fill();
      iconCtx.strokeStyle = "#a0522d"; iconCtx.lineWidth = 1.5; iconCtx.strokeRect(x, y+size*0.4, size, size*0.4);
      break;
    case "iron_bar":
      iconCtx.fillStyle = "#d8d8d8"; roundRect(iconCtx, x, y+size*0.4, size, size*0.4, 4); iconCtx.fill();
      iconCtx.strokeStyle = "#888"; iconCtx.lineWidth = 1.5; iconCtx.strokeRect(x, y+size*0.4, size, size*0.4);
      break;
    case "gold_bar":
      iconCtx.fillStyle = "#FFD700"; roundRect(iconCtx, x, y+size*0.4, size, size*0.4, 4); iconCtx.fill();
      iconCtx.strokeStyle = "#b89d00"; iconCtx.lineWidth = 1.5; iconCtx.strokeRect(x, y+size*0.4, size, size*0.4);
      break;
    case "sapphire_gem":
      iconCtx.fillStyle = "#aaaaff"; iconCtx.beginPath();
      iconCtx.moveTo(x+size/2, y);
      iconCtx.lineTo(x+size, y+size/2);
      iconCtx.lineTo(x+size/2, y+size);
      iconCtx.lineTo(x, y+size/2);
      iconCtx.closePath(); iconCtx.fill();
      iconCtx.strokeStyle = "#5e5ecf"; iconCtx.lineWidth = 2; iconCtx.stroke();
      break;
    case "iron_pickaxe":
      iconCtx.fillStyle = "#d8d8d8"; roundRect(iconCtx, x + size * 0.35, y + size * 0.3, size * 0.1, size * 0.5, 2); iconCtx.fill();
      iconCtx.fillStyle = "#888"; roundRect(iconCtx, x + size * 0.2, y + size * 0.2, size * 0.4, size * 0.12, 2); iconCtx.fill();
      break;
    case "iron_sword":
      iconCtx.fillStyle = "#d8d8d8"; roundRect(iconCtx, x + size * 0.45, y + size * 0.1, size * 0.1, size * 0.6, 2); iconCtx.fill();
      iconCtx.fillStyle = "#888"; roundRect(iconCtx, x + size * 0.4, y + size * 0.7, size * 0.2, size * 0.12, 2); iconCtx.fill();
      break;
    case "gold_pickaxe":
      iconCtx.fillStyle = "#FFD700"; roundRect(iconCtx, x + size * 0.35, y + size * 0.3, size * 0.1, size * 0.5, 2); iconCtx.fill();
      iconCtx.fillStyle = "#b89d00"; roundRect(iconCtx, x + size * 0.2, y + size * 0.2, size * 0.4, size * 0.12, 2); iconCtx.fill();
      break;
    case "sapphire_staff":
      iconCtx.fillStyle = "#aaaaff"; roundRect(iconCtx, x + size * 0.47, y + size * 0.18, size * 0.07, size * 0.6, 2); iconCtx.fill();
      iconCtx.fillStyle = "#5e5ecf"; iconCtx.beginPath(); iconCtx.arc(x + size * 0.5, y + size * 0.15, size * 0.13, 0, Math.PI * 2); iconCtx.fill();
      break;
    default: iconCtx.fillStyle = "#FFF"; roundRect(iconCtx, x, y, size, size, 5); iconCtx.fill();
  }
  iconCtx.restore();
}
document.getElementById("close-extra-inv").onclick = () => toggleExtraInventory(false);
window.addEventListener("keydown", e => {
  if (extraInventoryOpen && (e.key === "e" || e.key === "E" || e.key === "Escape" || e.key === "Enter")) {
    toggleExtraInventory(false);
    e.preventDefault();
  }
});
document.getElementById("extra-inventory-modal").addEventListener("mousedown", e => {
  if (e.target === document.getElementById("extra-inventory-modal")) toggleExtraInventory(false);
});

/* ===== DRAW MAIN GAME ===== */
function draw() {
  // Sky gradient
  const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grd.addColorStop(0, "#5cbbff");
  grd.addColorStop(1, "#aee6ff");
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Sun with glow
  ctx.save();
  ctx.shadowColor = "#ffef8e";
  ctx.shadowBlur = 40;
  ctx.beginPath();
  ctx.arc(80, 80, 30, 0, 2 * Math.PI);
  ctx.fillStyle = "#FFD200";
  ctx.fill();
  ctx.restore();

  resetLightMap();
  propagateTorchLight();

  const cameraX = player.x - canvas.width / 2 + player.width / 2, cameraY = player.y - canvas.height / 2 + player.height / 2;
  const startCol = Math.floor(cameraX / tileSize) - 1, endCol = startCol + Math.ceil(canvas.width / tileSize) + 2;
  const startRow = Math.floor(cameraY / tileSize) - 1, endRow = startRow + Math.ceil(canvas.height / tileSize) + 2;

  // === BLOCKY WORLD RENDERING ===
  for (let x = startCol; x <= endCol; x++) for (let y = startRow; y <= endRow; y++)
    if (x >= 0 && x < worldWidth && y >= 0 && y < worldHeight) {
      const block = world[x][y];
      if (block !== 0) {
        const drawX = x * tileSize - cameraX, drawY = y * tileSize - cameraY;
        let light = dynamicLightMap[x][y];
        ctx.save();
        ctx.fillStyle = blockColors[block] || "#FFF";
        ctx.fillRect(drawX, drawY, tileSize, tileSize);

        ctx.strokeStyle = blockEdgeColors[block] || "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1.4;
        ctx.strokeRect(drawX + 0.5, drawY + 0.5, tileSize - 1, tileSize - 1);

        // Dim if not fully lit (keep this for lighting)
        if (light < 0.99) {
          ctx.globalAlpha = 1 - Math.max(light, 0.40);
          ctx.fillStyle = "#000";
          ctx.fillRect(drawX, drawY, tileSize, tileSize);
          ctx.globalAlpha = 1.0;
        }
        ctx.restore();
      }
    }

  // Draw dropped items
  for (let drop of droppedItems)
    drawIcon(drop.key, drop.x * tileSize - cameraX, drop.y * tileSize - cameraY, tileSize);

  // Draw player
  if (playerImg.complete && playerImg.naturalWidth > 0)
    ctx.drawImage(playerImg, player.x - cameraX, player.y - cameraY, player.width, player.height);
  else {
    ctx.save();
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 10;
    ctx.fillStyle = "#fff";
    roundRect(ctx, player.x - cameraX, player.y - cameraY, player.width, player.height, 6);
    ctx.fill();
    ctx.restore();
  }

  // Draw selected item in hand
  const selectedItem = mainInventoryOrder[player.selectedSlot];
  // All pickaxes/staff/sword in hand
  if (player.inventory[selectedItem] > 0 && ["wooden_pickaxe", "wooden_sword", "iron_pickaxe", "iron_sword", "gold_pickaxe", "sapphire_staff", "torch"].includes(selectedItem)) {
    const handX = player.x + player.width, handY = player.y + player.height * 0.5;
    drawIcon(selectedItem, handX - cameraX, handY - cameraY, tileSize);
  }

  // Draw slimes
  for (let enemy of enemies) {
    let centerX = enemy.x + enemy.width / 2, centerY = enemy.y + enemy.height / 2;
    let dx = centerX - (player.x + player.width / 2), dy = centerY - (player.y + player.height / 2);
    if (Math.abs(dx) > canvas.width / 2 + 100 || Math.abs(dy) > canvas.height / 2 + 100) continue;
    let tileX = Math.floor(enemy.x / tileSize), tileY = Math.floor(enemy.y / tileSize);
    let light = (dynamicLightMap[tileX] && dynamicLightMap[tileX][tileY]) || 0.45;
    ctx.save();
    ctx.globalAlpha = Math.max(light, 0.55);
    ctx.shadowColor = "#44ff44";
    ctx.shadowBlur = 16;
    ctx.fillStyle = "#42ec4f";
    roundRect(ctx, enemy.x - cameraX, enemy.y - cameraY, enemy.width, enemy.height, 6);
    ctx.fill();
    ctx.shadowBlur = 0;
    // Slime eyes
    ctx.fillStyle = "#222";
    ctx.beginPath(); ctx.arc(enemy.x - cameraX + enemy.width*0.3, enemy.y - cameraY + enemy.height*0.5, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(enemy.x - cameraX + enemy.width*0.7, enemy.y - cameraY + enemy.height*0.5, 2.2, 0, Math.PI*2); ctx.fill();
    // HP bar
    let barWidth = enemy.width, barHeight = 4, hpFrac = Math.max(0, enemy.health / 20),
        bx = enemy.x - cameraX, by = enemy.y - cameraY - 8;
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = "#333"; roundRect(ctx, bx, by, barWidth, barHeight, 2); ctx.fill();
    ctx.fillStyle = "#1fff00"; roundRect(ctx, bx, by, barWidth * hpFrac, barHeight, 2); ctx.fill();
    ctx.restore();
  }

  // Health bar
  const barX = 20, barY = 20, barWidth = 200, barHeight = 20;
  ctx.save();
  ctx.shadowColor = "#ff4444";
  ctx.shadowBlur = 10;
  ctx.fillStyle = "#222";
  roundRect(ctx, barX, barY, barWidth, barHeight, 7); ctx.fill();
  ctx.fillStyle = "#e74c3c"; let healthFrac = Math.max(0, player.health / 100);
  roundRect(ctx, barX, barY, barWidth * healthFrac, barHeight, 7); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
  roundRect(ctx, barX, barY, barWidth, barHeight, 7); ctx.stroke();
  ctx.fillStyle = "#fff"; ctx.font = "16px Courier New";
  ctx.textAlign = "center";
  ctx.fillText("Health: " + Math.floor(player.health), barX + barWidth / 2, barY + barHeight - 4);
  ctx.restore();

  // Hunger bar
  const hungerBarX = barX, hungerBarY = barY + barHeight + 10, hungerBarWidth = 200, hungerBarHeight = 10;
  ctx.save();
  ctx.shadowColor = "#ffb900";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#222"; roundRect(ctx, hungerBarX, hungerBarY, hungerBarWidth, hungerBarHeight, 5); ctx.fill();
  ctx.fillStyle = "#ffa500"; let hungerFrac = Math.max(0, player.hunger / player.maxHunger);
  roundRect(ctx, hungerBarX, hungerBarY, hungerBarWidth * hungerFrac, hungerBarHeight, 5); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.strokeStyle = "#fff"; ctx.lineWidth = 1.2;
  roundRect(ctx, hungerBarX, hungerBarY, hungerBarWidth, hungerBarHeight, 5); ctx.stroke();
  ctx.fillStyle = "#fff"; ctx.font = "12px Courier New";
  ctx.textAlign = "center";
  ctx.fillText("Hunger: " + Math.floor(player.hunger) + "/" + player.maxHunger, hungerBarX + hungerBarWidth / 2, hungerBarY + hungerBarHeight - 2);
  ctx.restore();

  // XP bar
  const xpBarX = barX, xpBarY = hungerBarY + hungerBarHeight + 8, xpBarWidth = 200, xpBarHeight = 10;
  ctx.save();
  ctx.shadowColor = "#00bbff";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#222"; roundRect(ctx, xpBarX, xpBarY, xpBarWidth, xpBarHeight, 5); ctx.fill();
  ctx.fillStyle = "#00c3ff"; let xpFrac = Math.max(0, player.xp / player.xpToNext);
  roundRect(ctx, xpBarX, xpBarY, xpBarWidth * xpFrac, xpBarHeight, 5); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.strokeStyle = "#fff"; ctx.lineWidth = 1.2;
  roundRect(ctx, xpBarX, xpBarY, xpBarWidth, xpBarHeight, 5); ctx.stroke();
  ctx.fillStyle = "#fff"; ctx.font = "12px Courier New";
  ctx.textAlign = "center";
  ctx.fillText("XP: " + Math.floor(player.xp) + "/" + player.xpToNext, xpBarX + xpBarWidth / 2, xpBarY + xpBarHeight - 2);
  ctx.restore();

  // Mining progress
  if (currentMiningTarget) {
    const tx = currentMiningTarget.x, ty = currentMiningTarget.y;
    if (tx >= 0 && tx < worldWidth && ty >= 0 && ty < worldHeight) {
      const block = world[tx][ty];
      if (block !== 0 && blockDurability[block] !== undefined) {
        const bx = tx * tileSize - cameraX, by = ty * tileSize - cameraY, origDur = blockDurability[block];
        let progress = 1 - (blockHealth[tx][ty] / origDur); progress = Math.max(0, Math.min(1, progress));
        ctx.save();
        ctx.globalAlpha = 0.5 * progress;
        ctx.fillStyle = "gray";
        roundRect(ctx, bx, by, tileSize, tileSize, 4); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.fillStyle = "yellow"; roundRect(ctx, bx, by - 6, tileSize * progress, 4, 2); ctx.fill();
        ctx.strokeStyle = "black"; ctx.lineWidth = 1;
        roundRect(ctx, bx, by - 6, tileSize, 4, 2); ctx.stroke();
        ctx.restore();
      }
    }
  }
  drawFpsMeter(ctx);
  drawInventory();
  if (craftingMenuActive) drawCraftingMenu();
  if (isDead) {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = "48px Courier New"; ctx.textAlign = "center"; ctx.fillStyle = "#fff";
    ctx.fillText("You Died!", canvas.width / 2, canvas.height / 2 - 24);
    ctx.font = "24px Courier New";
    ctx.fillText("Click anywhere to respawn", canvas.width / 2, canvas.height / 2 + 24);
  }
}

/* ====== Game Loop ====== */
let isDead = false, droppedItems = [];
function updatePlayer() {
  if (craftingMenuActive || isDead || extraInventoryOpen) return;

  // Slower movement if hunger below 10
  let originalSpeed = player.speed;
  if (player.hunger < 10) {
    player.speed = 1.5; // reduced speed
  } else {
    player.speed = 4; // normal speed
  }

  if (keys["a"] || keys["ArrowLeft"]) player.vx = -player.speed;
  else if (keys["d"] || keys["ArrowRight"]) player.vx = player.speed;
  else player.vx = 0;
  if ((keys["w"] || keys["ArrowUp"] || keys[" "]) && player.grounded) {
    player.vy = -player.jumpStrength; player.grounded = false;
  }
  updateEntityPhysics(player);
  for (let i = droppedItems.length - 1; i >= 0; i--) {
    let drop = droppedItems[i], px = player.x + player.width / 2, py = player.y + player.height / 2,
        dx = drop.x * tileSize + tileSize / 2 - px, dy = drop.y * tileSize + tileSize / 2 - py;
    if (Math.abs(dx) < tileSize && Math.abs(dy) < tileSize) {
      player.inventory[drop.key] = (player.inventory[drop.key] || 0) + drop.amount;
      droppedItems.splice(i, 1);
    }
  }
}
function gameLoop() {
  updateFpsMeter();
  updatePlayer();
  updateHunger();
  updateEnemies();
  updateSlimeSpawning();
  updateMining();
  draw();
  requestAnimationFrame(gameLoop);
}
const playerImg = new Image();
playerImg.src = "assets/player.png";
playerImg.onload = function() { gameLoop(); };
if (playerImg.complete && playerImg.naturalWidth !== 0) gameLoop();

</script>
</body>
</html>
